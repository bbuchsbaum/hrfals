This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: R/**/*.R, R/**/*.r, *.Rmd, *.rmd, DESCRIPTION, tests/**/*.R, tests/**/*.r
- Files matching patterns in .gitignore are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
R/
  cf_als_engine.R
  cfals_design_utils.R
  cfals_methods.R
  cfals_wrapper.R
  ls_svd_1als_engine.R
  ls_svd_engine.R
tests/
  testthat/
    test-cf_als_engine.R
    test-cfals_design_utils.R
    test-cfals-wrapper.R
    test-ls_svd_1als_engine.R
    test-ls_svd_engine.R
DESCRIPTION
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="R/cf_als_engine.R">
#' Confound-Free ALS HRF Estimation Engine
#'
#' Internal helper implementing the CF-ALS algorithm described in
#' `data-raw/CFALS_proposal.md`. Inputs should already be projected
#' to the confound null space.
#'
#' @param X_list_proj list of k design matrices (n x d each)
#' @param Y_proj numeric matrix of projected BOLD data (n x v)
#' @param lambda_b ridge penalty for beta-update
#' @param lambda_h ridge penalty for h-update
#' @param R_mat optional d x d penalty matrix for h-update (defaults to identity if NULL)
#' @param fullXtX_flag logical; if TRUE use cross-condition terms in h-update
#' @param h_ref_shape_norm optional reference HRF shape for sign alignment
#' @param max_alt number of alternating updates after initialization
#' @param epsilon_svd tolerance for singular value screening
#' @param epsilon_scale tolerance for scale in identifiability step
#' @return list with matrices `h` (d x v) and `beta` (k x v). The
#'   matrix `h` has an attribute `"iterations"` recording the number
#'   of alternating updates performed.
#' @keywords internal
#' @noRd
cf_als_engine <- function(X_list_proj, Y_proj,
                          lambda_b = 10,
                          lambda_h = 1,
                          R_mat = NULL,
                          fullXtX_flag = FALSE,
                          h_ref_shape_norm = NULL,
                          max_alt = 1,
                          epsilon_svd = 1e-8,
                          epsilon_scale = 1e-8) {
  stopifnot(is.list(X_list_proj), length(X_list_proj) >= 1)
  n <- nrow(Y_proj)
  v <- ncol(Y_proj)
  d <- ncol(X_list_proj[[1]])
  k <- length(X_list_proj)
  for (X in X_list_proj) {
    if (nrow(X) != n) stop("Design matrices must have same rows as Y_proj")
    if (ncol(X) != d) stop("All design matrices must have the same column count")
  }
  if (lambda_b < 0 || lambda_h < 0) {
    stop("lambda_b and lambda_h must be non-negative")
  }

  if (!is.null(R_mat)) {
    if (!is.matrix(R_mat) || nrow(R_mat) != d || ncol(R_mat) != d) {
      stop(paste("R_mat must be a d x d matrix, where d is", d))
    }
  }

  cholSolve <- function(M, b, eps = max(epsilon_svd, epsilon_scale)) {
    ok <- TRUE
    L  <- tryCatch(chol(M), error = function(e) { ok <<- FALSE ; NULL })
    if (!ok || (is.null(L) || min(diag(L)) < eps)) {
      L <- chol(M + eps * diag(nrow(M)))
    }
    backsolve(L, forwardsolve(t(L), b))
  }

  init <- ls_svd_engine(X_list_proj, Y_proj,
                        lambda_init = 0,
                        h_ref_shape_norm = h_ref_shape_norm,
                        epsilon_svd = epsilon_svd,
                        epsilon_scale = epsilon_scale)
  h_current <- init$h
  b_current <- init$beta

  XtX_list <- lapply(X_list_proj, crossprod)
  XtY_list <- lapply(X_list_proj, function(X) crossprod(X, Y_proj))

  if (fullXtX_flag) {
    XtX_full_list <- matrix(vector("list", k * k), k, k)
    for (l in seq_len(k)) {
      for (m in seq_len(k)) {
        XtX_full_list[[l, m]] <- crossprod(X_list_proj[[l]], X_list_proj[[m]])
      }
    }
  } else {
    XtX_full_list <- NULL
  }

  for (iter in seq_len(max_alt)) {
    for (vx in seq_len(v)) {
      h_vx <- h_current[, vx]
      DhTy_vx <- vapply(seq_len(k), function(c)
        crossprod(h_vx, XtY_list[[c]][, vx]), numeric(1))
      G_vx <- matrix(0.0, k, k)
      for (l in seq_len(k)) {
        if (fullXtX_flag) {
          for (m in seq_len(k)) {
            term <- XtX_full_list[[l, m]]
            G_vx[l, m] <- crossprod(h_vx, term %*% h_vx)
          }
        } else {
          G_vx[l, l] <- crossprod(h_vx, XtX_list[[l]] %*% h_vx)
        }
      }
      b_current[, vx] <- cholSolve(G_vx + lambda_b * diag(k), DhTy_vx)
    }

    h_penalty_matrix <- if (is.null(R_mat)) {
      diag(d)
    } else {
      R_mat
    }

    for (vx in seq_len(v)) {
      b_vx <- b_current[, vx]
      lhs <- lambda_h * h_penalty_matrix 
      rhs <- numeric(d)
      for (l in seq_len(k)) {
        rhs <- rhs + b_vx[l] * XtY_list[[l]][, vx]
        if (fullXtX_flag) {
          for (m in seq_len(k)) {
            lhs <- lhs + b_vx[l] * b_vx[m] * XtX_full_list[[l, m]]
          }
        } else {
          lhs <- lhs + b_vx[l]^2 * XtX_list[[l]]
        }
      }
      h_current[, vx] <- cholSolve(lhs, rhs)
    }
  }

  scl <- apply(abs(h_current), 2, max)
  flip <- rep(1.0, v)
  if (!is.null(h_ref_shape_norm)) {
    align <- colSums(h_current * h_ref_shape_norm)
    flip[align < 0 & scl > epsilon_scale] <- -1.0
  }
  eff_scl <- pmax(scl, epsilon_scale)
  h_final <- sweep(h_current, 2, flip / eff_scl, "*")
  b_final <- sweep(b_current, 2, flip * eff_scl, "*")
  zero_idx <- scl <= epsilon_scale
  if (any(zero_idx)) {
    h_final[, zero_idx] <- 0
    b_final[, zero_idx] <- 0
  }

  attr(h_final, "iterations") <- max_alt
  list(h = h_final, beta = b_final)
}
</file>

<file path="R/cfals_design_utils.R">
#' CFALS Design Utilities
#'
#' Helper functions for interfacing the CF-ALS engine with the
#' fmrireg HRF basis system.
#'
#' @name cfals_design_utils
NULL

#' Reconstruction matrix for an HRF basis
#'
#' Returns a matrix \eqn{\Phi} that converts basis coefficients into a
#' sampled HRF shape.
#'
#' @param hrf An object of class `HRF`.
#' @param sframe A `sampling_frame` object or numeric vector of times.
#' @return A numeric matrix with one column per basis function.
#' @export
reconstruction_matrix <- function(hrf, sframe) {
  UseMethod("reconstruction_matrix")
}

#' @export
reconstruction_matrix.HRF <- function(hrf, sframe) {
  grid <- if (inherits(sframe, "sampling_frame")) {
    seq(0, attr(hrf, "span"), by = sframe$TR[1])
  } else {
    as.numeric(sframe)
  }
  vals <- evaluate(hrf, grid)
  if (is.vector(vals)) matrix(vals, ncol = 1L) else as.matrix(vals)
}

#' Penalty matrix for an HRF basis
#'
#' Provides a ridge or smoothness penalty matrix for the basis
#' coefficients. The default method returns an identity matrix.
#'
#' @param hrf An object of class `HRF`.
#' @return A square numeric matrix.
#' @export
penalty_matrix <- function(hrf) {
  UseMethod("penalty_matrix")
}

#' @export
penalty_matrix.HRF <- function(hrf) {
  diag(nbasis(hrf))
}

#' Project design and data matrices to the null space of confounds
#'
#' Projects both the data matrix `Y` and each design matrix in
#' `X_list` using QR decomposition of the confound matrix.  The
#' projection can optionally use LAPACK's QR implementation for
#' improved numerical stability.
#'
#' @param Y Numeric matrix of BOLD data (time points \eqn{\times}
#'   voxels).
#' @param X_list A list of design matrices with the same number of
#'   rows as `Y`.
#' @param confounds Optional confound matrix with matching rows.
#' @param lapack_qr Logical; passed to `qr()` as the `LAPACK`
#'   argument.
#' @return A list with projected `X_list` and `Y` matrices.
#' @export
project_confounds <- function(Y, X_list, confounds = NULL, lapack_qr = TRUE) {
  if (is.null(confounds)) {
    return(list(X_list = X_list, Y = Y))
  }
  qrZ <- qr(confounds, LAPACK = lapack_qr)
  Xp <- lapply(X_list, function(X) qr.resid(qrZ, X))
  Yp <- qr.resid(qrZ, Y)
  list(X_list = Xp, Y = Yp)
}

#' Create design matrices for CFALS estimation
#'
#' Convenience helper that constructs the list of design matrices for
#' a given `event_model` and HRF basis.  It also returns useful
#' metadata such as the number of basis functions and conditions as
#' well as a reconstruction matrix for converting HRF coefficients to
#' sampled shapes and a normalised reference HRF vector for sign
#' alignment.
#'
#' @param event_model An object of class `event_model`.
#' @param hrf_basis An `HRF` basis object.
#' @return A list with elements `X_list`, `d`, `k`, `Phi`, and
#'   `h_ref_shape_norm`.
#' @export
create_fmri_design <- function(event_model, hrf_basis) {
  if (!inherits(event_model, "event_model")) {
    stop("'event_model' must be an 'event_model' object")
  }
  if (!inherits(hrf_basis, "HRF")) {
    stop("'hrf_basis' must be an object of class 'HRF'")
  }

  sframe <- event_model$sampling_frame
  sample_times <- samples(sframe, global = TRUE)

  reg_lists <- lapply(event_model$terms, regressors.event_term,
                      hrf = hrf_basis,
                      sampling_frame = sframe,
                      summate = FALSE,
                      drop.empty = TRUE)
  regs <- unlist(reg_lists, recursive = FALSE)
  cond_names <- names(regs)
  X_list <- lapply(regs, function(r)
    evaluate(r, sample_times, precision = sframe$precision))
  names(X_list) <- cond_names

  Phi <- reconstruction_matrix(hrf_basis, sframe)
  h_ref <- drop(Phi[, 1])
  h_ref <- h_ref / max(abs(h_ref))

  list(X_list = X_list,
       d = nbasis(hrf_basis),
       k = length(X_list),
       Phi = Phi,
       h_ref_shape_norm = h_ref)
}
</file>

<file path="R/cfals_methods.R">
#' Construct an \code{fmrireg_cfals_fit} object
#'
#' Simple constructor used by [fmrireg_cfals()] to package the
#' results returned by the various CFALS engines.
#'
#' @param h_coeffs Matrix of HRF basis coefficients (d \eqn{\times} v).
#' @param beta_amps Matrix of condition amplitudes (k \eqn{\times} v).
#' @param method Character string indicating the estimation method.
#' @param lambdas Numeric vector of regularisation parameters.
#' @param call The matched call to the wrapper function.
#' @param hrf_basis HRF basis object used for the estimation.
#' @param design_info List with design metadata (d, k, n, v, fullXtX).
#' @param residuals Residual matrix from the projected data fit.
#' @param recon_hrf Matrix of reconstructed HRF shapes.
#' @param gof Numeric vector of goodness-of-fit statistics per voxel.
#' @return An object of class \code{fmrireg_cfals_fit}.
#' @description
#' Container class storing the results of CFALS estimation.  Fields
#' include the HRF basis coefficients (`h_coeffs`), condition amplitudes
#' (`beta_amps`), details of the estimation method, regularisation
#' parameters and design information.
#'
#' @examples
#' sframe <- sampling_frame(blocklens = 20, TR = 1)
#' ev_df <- data.frame(onset = c(5, 15), block = 1)
#' emod <- event_model(onset ~ hrf(constant), data = ev_df,
#'                     block = ~ block, sampling_frame = sframe)
#' Y <- matrix(rnorm(20 * 1), 20, 1)
#' fit <- fmrireg_cfals(Y, emod, HRF_SPMG1)
#' str(fit)
#' @export
fmrireg_cfals_fit <- function(h_coeffs, beta_amps, method, lambdas, call,
                              hrf_basis, design_info, residuals,
                              recon_hrf = NULL, gof = NULL) {
  out <- list(h_coeffs = h_coeffs,
              beta_amps = beta_amps,
              method_used = method,
              lambdas = lambdas,
              call = call,
              hrf_basis_used = hrf_basis,
              design_info = design_info,
              residuals = residuals,
              reconstructed_hrfs = recon_hrf,
              gof_per_voxel = gof)
  class(out) <- c("fmrireg_cfals_fit", "list")
  out
}

#' Methods for fmrireg_cfals_fit Objects
#'
#' Basic utilities for inspecting the results
#' of `fmrireg_hrf_cfals`.
#'
#' @param x,object An `fmrireg_cfals_fit` object.
#' @param vox Index of the voxel to plot.
#' @param ... Additional arguments passed to underlying functions.
#' @export
print.fmrireg_cfals_fit <- function(x, ...) {
  cat("\nfmrireg CF-ALS Fit\n")
  cat("==================\n")
  info <- x$design_info
  cat(sprintf("Voxels: %d\n", info$v))
  cat(sprintf("Time points: %d\n", info$n))
  cat(sprintf("Conditions: %d\n", info$k))
  cat(sprintf("Basis functions: %d\n", info$d))
  invisible(x)
}

#' @export
summary.fmrireg_cfals_fit <- function(object, ...) {
  res <- list(r2 = object$gof_per_voxel,
              design = object$design_info,
              lambdas = object$lambdas)
  class(res) <- "summary.fmrireg_cfals_fit"
  res
}

#' @export
residuals.fmrireg_cfals_fit <- function(object, ...) {
  object$residuals
}

#' @export
plot.fmrireg_cfals_fit <- function(x, vox = 1, ...) {
  if (vox < 1 || vox > ncol(x$reconstructed_hrfs))
    stop("'vox' out of range")
  hrf <- x$reconstructed_hrfs[, vox]
  plot(hrf, type = "l", xlab = "Time index", ylab = "Amplitude",
       main = paste("Reconstructed HRF - voxel", vox), ...)
}
</file>

<file path="R/ls_svd_1als_engine.R">
#' LS+SVD+1ALS Rank-1 HRF Estimation Engine
#'
#' Internal helper implementing the LS+SVD+1ALS algorithm described in
#' `data-raw/LSS+SVD_proposal.md`. Inputs should be projected to the
#' confound null space.
#'
#' @param X_list_proj list of k design matrices (n x d each)
#' @param Y_proj numeric matrix of projected BOLD data (n x v)
#' @param lambda_init ridge penalty for initial GLM solve
#' @param lambda_b ridge penalty for \eqn{\beta}-update
#' @param lambda_h ridge penalty for \eqn{h}-update
#' @param fullXtX_flag logical; if TRUE use full cross-terms in h-update
#' @param h_ref_shape_norm optional reference HRF shape for sign alignment
#' @param svd_backend backend for SVD in the initialization step
#' @param epsilon_svd tolerance for singular value screening
#' @param epsilon_scale tolerance for scale in identifiability step
#' @return list with matrices `h` (d x v), `beta` (k x v) and the
#'         initial estimates `h_ls_svd`, `beta_ls_svd`
#' @keywords internal
#' @noRd
ls_svd_1als_engine <- function(X_list_proj, Y_proj,
                               lambda_init = 1,
                               lambda_b = 10,
                               lambda_h = 1,
                               fullXtX_flag = FALSE,
                               h_ref_shape_norm = NULL,
                               svd_backend = c("base_R"),
                               epsilon_svd = 1e-8,
                               epsilon_scale = 1e-8) {

  if (lambda_init < 0 || lambda_b < 0 || lambda_h < 0)
    stop("Lambdas must be non-negative")
  stopifnot(is.list(X_list_proj), length(X_list_proj) >= 1)
  d <- ncol(X_list_proj[[1]])
  if (!is.null(h_ref_shape_norm) && length(h_ref_shape_norm) != d)
    stop("`h_ref_shape_norm` must be length d")

  cholSolve <- function(M, B) {
    R <- tryCatch(chol(M),
                  error = function(e) chol(M + 1e-6 * diag(nrow(M))))
    backsolve(R, forwardsolve(t(R), B))
  }
  init <- ls_svd_engine(X_list_proj, Y_proj,
                        lambda_init = lambda_init,
                        h_ref_shape_norm = h_ref_shape_norm,
                        svd_backend = svd_backend,
                        epsilon_svd = epsilon_svd,
                        epsilon_scale = epsilon_scale)

  h_current <- init$h
  b_current <- init$beta
  k <- length(X_list_proj)
  d <- ncol(X_list_proj[[1]])
  v <- ncol(Y_proj)

  XtX_list <- lapply(X_list_proj, crossprod)
  XtY_list <- lapply(X_list_proj, function(X) crossprod(X, Y_proj))

  XtX_full_list <- NULL
  if (fullXtX_flag) {
    XtX_full_list <- matrix(vector("list", k * k), k, k)
    for (l in seq_len(k)) {
      for (m in seq_len(k)) {
        XtX_full_list[[l, m]] <- crossprod(X_list_proj[[l]], X_list_proj[[m]])
      }
    }
  }

  H_als <- matrix(0.0, d, v)
  B_als <- matrix(0.0, k, v)

  for (vx in seq_len(v)) {
    h_vx <- h_current[, vx]
    DhTy_vx <- vapply(seq_len(k), function(c)
      crossprod(h_vx, XtY_list[[c]][, vx]), numeric(1))
    if (fullXtX_flag) {
      G_vx <- matrix(0.0, k, k)
      for (l in seq_len(k)) {
        for (m in seq_len(k)) {
          G_vx[l, m] <- crossprod(h_vx, XtX_full_list[[l, m]] %*% h_vx)
        }
      }
    } else {
      diag_vals <- vapply(seq_len(k), function(c)
        crossprod(h_vx, XtX_list[[c]] %*% h_vx), numeric(1))
      G_vx <- diag(diag_vals, k)
    }
    B_als[, vx] <- cholSolve(G_vx + lambda_b * diag(k), DhTy_vx)
  }

  b_current <- B_als

  for (vx in seq_len(v)) {
    b_vx <- b_current[, vx]
    lhs <- lambda_h * diag(d)
    rhs <- numeric(d)
    for (l in seq_len(k)) {
      rhs <- rhs + b_vx[l] * XtY_list[[l]][, vx]
      if (fullXtX_flag) {
        for (m in seq_len(k)) {
          lhs <- lhs + b_vx[l] * b_vx[m] * XtX_full_list[[l, m]]
        }
      } else {
        lhs <- lhs + b_vx[l]^2 * XtX_list[[l]]
      }
    }
    H_als[, vx] <- cholSolve(lhs, rhs)
  }

  scl <- apply(abs(H_als), 2, max)
  flip <- rep(1.0, v)
  if (!is.null(h_ref_shape_norm)) {
    align <- as.numeric(crossprod(h_ref_shape_norm, H_als))
    flip[align < 0 & scl > epsilon_scale] <- -1.0
  }
  eff_scl <- pmax(scl, epsilon_scale)
  H_final <- sweep(H_als, 2, flip / eff_scl, "*")
  B_final <- sweep(B_als, 2, flip * eff_scl, "*")
  zero_idx <- scl <= epsilon_scale
  if (any(zero_idx)) {
    H_final[, zero_idx] <- 0
    B_final[, zero_idx] <- 0
  }

  dimnames(H_final) <- list(NULL, colnames(Y_proj))
  dimnames(B_final) <- list(names(X_list_proj), colnames(Y_proj))

  list(h = H_final, beta = B_final,
       h_ls_svd = init$h, beta_ls_svd = init$beta)
}
</file>

<file path="R/ls_svd_engine.R">
#' LS+SVD Rank-1 HRF Estimation Engine
#'
#' Internal helper implementing the LS+SVD algorithm described in
#' `data-raw/LSS+SVD_proposal.md`. The design matrices should already
#' be projected to the confound null space.
#'
#' @param X_list_proj list of k design matrices (n x d each)
#' @param Y_proj      numeric matrix of projected BOLD data (n x v)
#' @param lambda_init ridge penalty for initial GLM solve
#' @param h_ref_shape_norm optional reference HRF shape for sign alignment
#' @param svd_backend currently ignored, placeholder for future backends
#' @param epsilon_svd tolerance for singular value screening
#' @param epsilon_scale tolerance for scale in identifiability step
#' @return list with matrices `h` (d x v), `beta` (k x v) and
#'         `Gamma_hat` (d*k x v)
#' @keywords internal
#' @noRd
ls_svd_engine <- function(X_list_proj, Y_proj, lambda_init = 1, 
                          h_ref_shape_norm = NULL,
                          svd_backend = c("base_R"),
                          epsilon_svd = 1e-8,
                          epsilon_scale = 1e-8) {
  svd_backend <- match.arg(svd_backend)
  stopifnot(is.list(X_list_proj), length(X_list_proj) >= 1)
  n <- nrow(Y_proj)
  v <- ncol(Y_proj)
  d <- ncol(X_list_proj[[1]])
  k <- length(X_list_proj)
  for (X in X_list_proj) {
    if (nrow(X) != n) stop("Design matrices must have same rows as Y_proj")
    if (ncol(X) != d) stop("All design matrices must have the same column count")
  }
  if (!is.null(h_ref_shape_norm) && length(h_ref_shape_norm) != d)
    stop("`h_ref_shape_norm` must have length d")

  cholSolve <- function(M, B, eps = max(epsilon_svd, epsilon_scale)) {
    L <- tryCatch(chol(M),
                  error = function(e) chol(M + eps * diag(nrow(M))))
    backsolve(L, forwardsolve(t(L), B))
  }

  Xbig <- do.call(cbind, X_list_proj)
  XtX  <- crossprod(Xbig)
  Xty  <- crossprod(Xbig, Y_proj)
  XtX_ridge <- XtX + lambda_init * diag(ncol(Xbig))
  Gamma_hat <- cholSolve(XtX_ridge, Xty)

  H_out <- matrix(0.0, d, v)
  B_out <- matrix(0.0, k, v)

  for (vx in seq_len(v)) {
    G_vx <- matrix(Gamma_hat[, vx], nrow = d, ncol = k)
    sv <- svd(G_vx, nu = 1, nv = 1)
    if (length(sv$d) && sv$d[1] > epsilon_svd) {
      s1 <- sqrt(sv$d[1])
      H_out[, vx] <- sv$u[, 1] * s1
      B_out[, vx] <- sv$v[, 1] * s1
    }
  }

  scl <- apply(abs(H_out), 2, max)
  flip <- rep(1.0, v)
  if (!is.null(h_ref_shape_norm)) {
    align <- as.numeric(crossprod(h_ref_shape_norm, H_out))
    flip[align < 0 & scl > epsilon_scale] <- -1.0
  }
  eff_scl <- pmax(scl, epsilon_scale)
  H_final <- sweep(H_out, 2, flip / eff_scl, "*")
  B_final <- sweep(B_out, 2, flip * eff_scl, "*")
  zero_idx <- scl <= epsilon_scale
  if (any(zero_idx)) {
    H_final[, zero_idx] <- 0
    B_final[, zero_idx] <- 0
  }

  dimnames(H_final) <- list(NULL, colnames(Y_proj))
  dimnames(B_final) <- list(names(X_list_proj), colnames(Y_proj))

  list(h = H_final, beta = B_final, Gamma_hat = Gamma_hat)
}
</file>

<file path="tests/testthat/test-cf_als_engine.R">
context("cf_als_engine")

simple_cfals_data <- function() {
  set.seed(123)
  n <- 50
  d <- 3
  k <- 2
  v <- 4
  h_true <- matrix(rnorm(d * v), d, v)
  beta_true <- matrix(rnorm(k * v), k, v)
  X_list <- lapply(seq_len(k), function(i) matrix(rnorm(n * d), n, d))
  Xbig <- do.call(cbind, X_list)
  Y <- Xbig %*% as.vector(matrix(h_true, d, v) %*% t(beta_true))
  Y <- matrix(Y, n, v)
  list(X_list = X_list, Y = Y, d = d, k = k)
}

test_that("cf_als_engine returns matrices with correct dimensions", {
  dat <- simple_cfals_data()
  res <- cf_als_engine(dat$X_list, dat$Y,
                       lambda_b = 0.1,
                       lambda_h = 0.1,
                       fullXtX_flag = FALSE,
                       max_alt = 1)
  expect_equal(dim(res$h), c(dat$d, ncol(dat$Y)))
  expect_equal(dim(res$beta), c(dat$k, ncol(dat$Y)))
})
</file>

<file path="tests/testthat/test-cfals_design_utils.R">
context("cfals design helpers")

test_that("reconstruction_matrix works", {
  sf <- sampling_frame(10, TR = 1)
  phi <- reconstruction_matrix(HRF_SPMG1, sf)
  expect_equal(ncol(phi), nbasis(HRF_SPMG1))
  expect_gt(nrow(phi), 1)
})

test_that("penalty_matrix defaults to identity", {
  Rm <- penalty_matrix(HRF_SPMG1)
  expect_equal(Rm, diag(nbasis(HRF_SPMG1)))
})

test_that("project_confounds projects via QR", {
  X <- matrix(rnorm(20), 5, 4)
  Y <- matrix(rnorm(10), 5, 2)
  Z <- matrix(seq_len(5), ncol = 1)
  res <- project_confounds(Y, list(X), Z)
  expect_equal(dim(res$X_list[[1]]), dim(X))
  expect_equal(dim(res$Y), dim(Y))
})

test_that("create_fmri_design returns expected structure", {
  sf <- sampling_frame(20, TR = 1)
  events <- data.frame(onset = c(2, 6, 12),
                       condition = factor(c("A", "B", "A")),
                       block = 1)
  emod <- event_model(onset ~ hrf(condition), data = events,
                      block = ~ block, sampling_frame = sf)
  des <- create_fmri_design(emod, HRF_SPMG1)
  expect_type(des, "list")
  expect_equal(length(des$X_list), 2)
  expect_equal(des$d, nbasis(HRF_SPMG1))
  expect_equal(des$k, length(des$X_list))
  expect_true(is.matrix(des$Phi))
  expect_true(is.numeric(des$h_ref_shape_norm))
})
</file>

<file path="tests/testthat/test-cfals-wrapper.R">
context("cfals wrapper")

library(fmrireg)

simulate_cfals_wrapper_data <- function(hrf_basis, noise_sd = 0.05, signal_scale = 1) {
  sf <- sampling_frame(blocklens = 60, TR = 1)
  events <- data.frame(
    onset = c(5, 15, 30, 45),
    condition = factor(c("A", "A", "B", "B")),
    block = 1
  )
  emod <- event_model(onset ~ hrf(condition), data = events,
                      block = ~ block, sampling_frame = sf)
  reg_lists <- lapply(emod$terms, regressors.event_term,
                      hrf = hrf_basis,
                      sampling_frame = sf,
                      summate = FALSE,
                      drop.empty = TRUE)
  regs <- unlist(reg_lists, recursive = FALSE)
  sample_times <- samples(sf, global = TRUE)
  X_list <- lapply(regs, function(r)
    evaluate(r, sample_times, precision = sf$precision))
  d <- nbasis(hrf_basis)
  k <- length(X_list)
  v <- 2
  h_true <- matrix(rnorm(d * v), d, v) * signal_scale
  beta_true <- matrix(rnorm(k * v), k, v) * signal_scale
  Y <- matrix(0, nrow(sample_times), v)
  for (c in seq_along(X_list)) {
    Y <- Y + (X_list[[c]] %*% h_true) *
      matrix(rep(beta_true[c, ], each = nrow(Y)), nrow(Y), v)
  }
  Y <- Y + matrix(rnorm(length(Y), sd = noise_sd), nrow(Y), v)
  attr(Y, "sampling_frame") <- sf
  list(Y = Y, event_model = emod, X_list = X_list,
       h_true = h_true, beta_true = beta_true, sframe = sf)
}


test_that("fmrireg_hrf_cfals works across HRF bases", {
  bases <- list(HRF_SPMG3, hrfspline_generator(nbasis = 4))
  for (b in bases) {
    dat <- simulate_cfals_wrapper_data(b)
    fit <- fmrireg_hrf_cfals(dat$Y, dat$event_model, b,
                             lam_beta = 0.1, lam_h = 0.1)
    expect_equal(dim(fit$h_coeffs), c(nbasis(b), ncol(dat$Y)))
    expect_equal(dim(fit$beta_amps), c(length(dat$X_list), ncol(dat$Y)))
    recon <- reconstruction_matrix(b, dat$sframe) %*% fit$h_coeffs
    expect_true(all(is.finite(recon)))
  }
})

test_that("fmrireg_cfals wrapper supports multiple methods", {
  dat <- simulate_cfals_wrapper_data(HRF_SPMG3)
  methods <- c("ls_svd_only", "ls_svd_1als", "cf_als")
  for (m in methods) {
    fit <- fmrireg_cfals(dat$Y, dat$event_model, HRF_SPMG3,
                         method = m, lambda_b = 0.1, lambda_h = 0.1,
                         lambda_init = 0.5, max_alt = 1)
    expect_equal(dim(fit$h_coeffs), c(nbasis(HRF_SPMG3), ncol(dat$Y)))
    expect_equal(dim(fit$beta_amps), c(length(dat$X_list), ncol(dat$Y)))
  }
})

test_that("cfals handles low-signal data", {
  dat <- simulate_cfals_wrapper_data(HRF_SPMG3, noise_sd = 0.5, signal_scale = 0.01)
  fit <- fmrireg_hrf_cfals(dat$Y, dat$event_model, HRF_SPMG3)
  expect_lt(mean(fit$gof_per_voxel), 0.2)
})

simple_cfals_data_noise <- function() {
  set.seed(123)
  n <- 50
  d <- 3
  k <- 2
  v <- 3
  h_true <- matrix(rnorm(d * v), d, v)
  beta_true <- matrix(rnorm(k * v), k, v)
  X_list <- lapply(seq_len(k), function(i) matrix(rnorm(n * d), n, d))
  Xbig <- do.call(cbind, X_list)
  Y <- Xbig %*% as.vector(matrix(h_true, d, v) %*% t(beta_true))
  Y <- matrix(Y, n, v) + matrix(rnorm(n * v, sd = 0.01), n, v)
  list(X_list = X_list, Y = Y, Xbig = Xbig)
}

test_that("cf_als_engine predictions match canonical GLM", {
  dat <- simple_cfals_data_noise()
  res <- cf_als_engine(dat$X_list, dat$Y,
                       lambda_b = 0,
                       lambda_h = 0,
                       fullXtX_flag = FALSE,
                       max_alt = 1)
  n <- nrow(dat$Y)
  v <- ncol(dat$Y)
  pred_cfals <- matrix(0, n, v)
  for (c in seq_along(dat$X_list)) {
    pred_cfals <- pred_cfals + (dat$X_list[[c]] %*% res$h) *
      matrix(rep(res$beta[c, ], each = n), n, v)
  }
  gamma_hat <- chol2inv(chol(crossprod(dat$Xbig))) %*% crossprod(dat$Xbig, dat$Y)
  pred_glm <- dat$Xbig %*% gamma_hat
  expect_equal(pred_cfals, pred_glm, tolerance = 1e-5)
})

test_that("fullXtX argument is forwarded through fmrireg_cfals", {
  dat <- simulate_cfals_wrapper_data(HRF_SPMG3)
  design <- create_fmri_design(dat$event_model, HRF_SPMG3)
  proj <- project_confounds(dat$Y, design$X_list, NULL)
  direct <- ls_svd_1als_engine(proj$X_list, proj$Y,
                               lambda_init = 0,
                               lambda_b = 0.1,
                               lambda_h = 0.1,
                               fullXtX_flag = TRUE,
                               h_ref_shape_norm = design$h_ref_shape_norm)
  wrap <- fmrireg_cfals(dat$Y, dat$event_model, HRF_SPMG3,
                        method = "ls_svd_1als",
                        fullXtX = TRUE,
                        lambda_init = 0,
                        lambda_b = 0.1,
                        lambda_h = 0.1)
  expect_equal(wrap$h_coeffs, direct$h)
  expect_equal(wrap$beta_amps, direct$beta)
})
</file>

<file path="tests/testthat/test-ls_svd_1als_engine.R">
library(testthat)

context("ls_svd_1als_engine")

simple_ls_svd_data <- function() {
  set.seed(123)
  n <- 50
  d <- 3
  k <- 2
  v <- 4
  h_true <- matrix(rnorm(d * v), d, v)
  beta_true <- matrix(rnorm(k * v), k, v)
  X_list <- lapply(seq_len(k), function(i) matrix(rnorm(n * d), n, d))
  Xbig <- do.call(cbind, X_list)
  Y <- Xbig %*% as.vector(matrix(h_true, d, v) %*% t(beta_true))
  Y <- matrix(Y, n, v)
  list(X_list = X_list, Y = Y, d = d, k = k)
}

test_that("ls_svd_1als_engine returns matrices with correct dimensions", {
  dat <- simple_ls_svd_data()
  res <- ls_svd_1als_engine(dat$X_list, dat$Y,
                            lambda_init = 0,
                            lambda_b = 0.1,
                            lambda_h = 0.1)
  expect_equal(dim(res$h), c(dat$d, ncol(dat$Y)))
  expect_equal(dim(res$beta), c(dat$k, ncol(dat$Y)))
  expect_equal(dim(res$h_ls_svd), c(dat$d, ncol(dat$Y)))
  expect_equal(dim(res$beta_ls_svd), c(dat$k, ncol(dat$Y)))
})

single_condition_data <- function() {
  set.seed(42)
  n <- 40
  d <- 2
  v <- 3
  X <- matrix(rnorm(n * d), n, d)
  h_true <- matrix(rnorm(d * v), d, v)
  b_true <- rnorm(v)
  Y <- (X %*% h_true) * matrix(rep(b_true, each = n), n, v)
  list(X_list = list(X), Y = Y)
}

test_that("fullXtX_flag has no effect for single condition", {
  dat <- single_condition_data()
  res_diag <- ls_svd_1als_engine(dat$X_list, dat$Y,
                                 lambda_init = 0,
                                 lambda_b = 0.1,
                                 lambda_h = 0.1,
                                 fullXtX_flag = FALSE)
  res_full <- ls_svd_1als_engine(dat$X_list, dat$Y,
                                 lambda_init = 0,
                                 lambda_b = 0.1,
                                 lambda_h = 0.1,
                                 fullXtX_flag = TRUE)
  expect_equal(res_diag$h, res_full$h)
  expect_equal(res_diag$beta, res_full$beta)
})

correlated_data <- function() {
  set.seed(99)
  n <- 40
  d <- 2
  k <- 2
  v <- 2
  baseX <- matrix(rnorm(n * d), n, d)
  X_list <- list(baseX, baseX + matrix(rnorm(n * d, sd = 0.2), n, d))
  h_true <- matrix(rnorm(d * v), d, v)
  beta_true <- matrix(rnorm(k * v), k, v)
  Xbig <- do.call(cbind, X_list)
  Y <- Xbig %*% as.vector(matrix(h_true, d, v) %*% t(beta_true))
  Y <- matrix(Y, n, v)
  list(X_list = X_list, Y = Y)
}

test_that("fullXtX_flag influences estimates when conditions correlate", {
  dat <- correlated_data()
  res_diag <- ls_svd_1als_engine(dat$X_list, dat$Y,
                                 lambda_init = 0,
                                 lambda_b = 0.1,
                                 lambda_h = 0.1,
                                 fullXtX_flag = FALSE)
  res_full <- ls_svd_1als_engine(dat$X_list, dat$Y,
                                 lambda_init = 0,
                                 lambda_b = 0.1,
                                 lambda_h = 0.1,
                                 fullXtX_flag = TRUE)
  expect_false(isTRUE(all.equal(res_diag$h, res_full$h)))
})
</file>

<file path="tests/testthat/test-ls_svd_engine.R">
library(testthat)

context("ls_svd_engine")

simple_ls_svd_data <- function() {
  set.seed(123)
  n <- 50
  d <- 3
  k <- 2
  v <- 5
  h_true <- matrix(rnorm(d * v), d, v)
  beta_true <- matrix(rnorm(k * v), k, v)
  X_list <- lapply(seq_len(k), function(i) matrix(rnorm(n * d), n, d))
  Xbig <- do.call(cbind, X_list)
  Y <- Xbig %*% as.vector(matrix(h_true, d, v) %*% t(beta_true))
  Y <- matrix(Y, n, v)
  list(X_list = X_list, Y = Y, d = d, k = k)
}


test_that("ls_svd_engine returns matrices with correct dimensions", {
  dat <- simple_ls_svd_data()
  res <- ls_svd_engine(dat$X_list, dat$Y, lambda_init = 0)
  expect_equal(dim(res$h), c(dat$d, ncol(dat$Y)))
  expect_equal(dim(res$beta), c(dat$k, ncol(dat$Y)))
  expect_equal(dim(res$Gamma_hat), c(dat$d * dat$k, ncol(dat$Y)))
})
</file>

<file path="R/cfals_wrapper.R">
#' Estimate Rank-1 HRF Using LS+SVD/CF-ALS Methods
#'
#' High level wrapper that prepares design matrices and dispatches to
#' the desired estimation engine.  This function supports the fast
#' \emph{LS+SVD} initialisation, the one-step refinement
#' \emph{LS+SVD+1ALS}, or the full alternating scheme implemented in
#' `cf_als_engine`.
#'
#' @param fmri_data_obj An `fmri_dataset` or numeric matrix of BOLD data
#'   (time points x voxels). If a dataset, sampling information is
#'   taken from the object.
#' @param event_model An `event_model` describing the stimuli to use
#'   for HRF estimation.
#' @param hrf_basis An `HRF` basis object used for the convolution
#'   design matrices.
#' @param confound_obj Optional matrix of confound regressors with the
#'   same number of rows as the data matrix.
#' @param method Estimation method. One of "ls_svd_only",
#'   "ls_svd_1als" (default) or "cf_als".
#' @param lambda_init Ridge penalty for the initial GLM solve used by
#'   `ls_svd` based methods.
#' @param lambda_b Ridge penalty for the beta update step.
#' @param lambda_h Ridge penalty for the h update step.
#' @param R_mat Optional penalty matrix for the h (HRF coefficient) update.
#'   If `NULL` (default), an identity matrix is used, corresponding to a simple
#'   ridge penalty. If a basis-specific penalty (e.g., for smoothing) is
#'   available from `hrf_basis`, it can be passed here.
#' @param fullXtX Logical; if `TRUE` include cross condition terms in
#'   the h update (where supported).
#' @param max_alt Number of alternating updates after initialisation
#'   when `method = "cf_als"`.
#' @param ... Additional arguments passed to the underlying estimation engine.
#' @return An object of class `fmrireg_cfals_fit` containing the
#'   estimated HRF coefficients and amplitudes.
#' @details
#' The `method` argument selects between the closed-form
#' \code{"ls_svd_only"}, the default \code{"ls_svd_1als"} which adds one
#' ALS refinement step, or the iterative \code{"cf_als"} engine.  The
#' ridge penalties \code{lambda_init}, \code{lambda_b} and
#' \code{lambda_h} control regularisation of the initial solve, the
#' beta-update and the h-update respectively.  Setting
#' \code{fullXtX = TRUE} includes cross-condition terms in the h-update
#' (when supported by the chosen engine).  R\eqn{^2} is computed on the
#' data after confound projection.
#'
#' @examples
#' sframe <- sampling_frame(blocklens = 40, TR = 1)
#' ev_df <- data.frame(onset = c(5, 15, 25), block = 1)
#' emod <- event_model(onset ~ hrf(constant), data = ev_df,
#'                     block = ~ block, sampling_frame = sframe)
#' Y <- matrix(rnorm(40 * 2), 40, 2)
#' fit <- fmrireg_cfals(Y, emod, HRF_SPMG1)
#' print(fit)
#' @export
fmrireg_cfals <- function(fmri_data_obj,
                         event_model,
                         hrf_basis,
                         confound_obj = NULL,
                         method = c("ls_svd_1als", "ls_svd_only", "cf_als"),
                         lambda_init = 1,
                         lambda_b = 10,
                         lambda_h = 1,
                         R_mat = NULL,
                         fullXtX = FALSE,
                         max_alt = 1,
                         ...) {

  method <- match.arg(method)

  if (inherits(fmri_data_obj, "fmri_dataset")) {
    Y <- get_data_matrix(fmri_data_obj)
  } else if (is.matrix(fmri_data_obj)) {
    Y <- fmri_data_obj
  } else {
    stop("'fmri_data_obj' must be an 'fmri_dataset' or matrix")
  }

  sframe <- if (inherits(fmri_data_obj, "fmri_dataset"))
    fmri_data_obj$sampling_frame else attr(fmri_data_obj, "sampling_frame")

  if (is.null(sframe)) {
    stop("Sampling information could not be determined from input")
  }

  design <- create_fmri_design(event_model, hrf_basis)
  X_list <- design$X_list
  cond_names <- names(X_list)

  proj <- project_confounds(Y, X_list, confound_obj)
  Xp <- proj$X_list
  Yp <- proj$Y

  fit <- switch(method,
    ls_svd_only = ls_svd_engine(Xp, Yp,
                                lambda_init = lambda_init,
                                h_ref_shape_norm = design$h_ref_shape_norm,
                                R_mat = R_mat, ...),
    ls_svd_1als = ls_svd_1als_engine(Xp, Yp,
                                     lambda_init = lambda_init,
                                     lambda_b = lambda_b,
                                     lambda_h = lambda_h,
                                     fullXtX_flag = fullXtX,
                                     h_ref_shape_norm = design$h_ref_shape_norm,
                                     R_mat = R_mat, ...),
    cf_als = cf_als_engine(Xp, Yp,
                           lambda_b = lambda_b,
                           lambda_h = lambda_h,
                           fullXtX_flag = fullXtX,
                           h_ref_shape_norm = design$h_ref_shape_norm,
                           max_alt = max_alt,
                           R_mat = R_mat, ...)
  )

  rownames(fit$beta) <- cond_names

  Phi <- design$Phi
  recon_hrf <- Phi %*% fit$h

  n <- nrow(Yp)
  v <- ncol(Yp)
  pred_p <- Reduce(`+`, Map(function(Xc, bc) {
    Xc %*% (fit$h * matrix(bc, nrow = nrow(fit$h), ncol = v, byrow = TRUE))
  }, Xp, asplit(fit$beta, 1)))
  resids <- Yp - pred_p

  SST <- colSums((Yp - matrix(colMeans(Yp), n, v, TRUE))^2)
  SSE <- colSums(resids^2)
  r2 <- 1 - SSE / SST

  out <- fmrireg_cfals_fit(h_coeffs = fit$h,
                           beta_amps = fit$beta,
                           method = method,
                           lambdas = c(init = lambda_init,
                                       beta = lambda_b,
                                       h = lambda_h),
                           call = match.call(),
                           hrf_basis = hrf_basis,
                           design_info = list(d = design$d,
                                              k = length(X_list),
                                              n = n,
                                              v = v,
                                              fullXtX = fullXtX),
                           residuals = resids,
                           recon_hrf = recon_hrf,
                           gof = r2)
  out
}

#' Fit Rank-1 HRF Using CF-ALS
#'
#' Convenience wrapper for the original CF-ALS implementation.  This
#' function simply calls [fmrireg_cfals()] with `method = "cf_als"` and
#' retains the historical argument names.
#'
#' @param fmri_data_obj An `fmri_dataset` or numeric matrix of BOLD data
#'   (time points x voxels). If a dataset, sampling information is
#'   taken from the object.
#' @param event_model An `event_model` describing the stimuli to use
#'   for HRF estimation.
#' @param hrf_basis An `HRF` basis object from the `fmrireg` package
#'   (e.g., `HRF_BSPLINE`, `HRF_TENT`, `HRF_SPMG1`). This determines the
#'   set of basis functions used to model the HRF. The CF-ALS method
#'   can work with any basis where `nbasis > 1`.
#' @param confound_obj Optional numeric matrix of confound regressors (time
#'   points x number of confounds). These nuisance variables are projected
#'   out from the BOLD data and design matrices prior to CF-ALS estimation.
#'   Defaults to `NULL` (no confounds).
#' @param lam_beta Numeric. The regularization parameter for the beta (amplitude)
#'   update step. Controls the L2 penalty on the amplitude coefficients.
#'   Defaults to 10.
#' @param lam_h Numeric. The regularization parameter for the h (HRF coefficient)
#'   update step. Controls the L2 penalty on the HRF basis coefficients.
#'   Defaults to 1.
#' @param R_mat Optional penalty matrix for the h (HRF coefficient) update.
#'   If `NULL` (default), an identity matrix is used, corresponding to a simple
#'   ridge penalty. If a basis-specific penalty (e.g., for smoothing) is
#'   available from `hrf_basis`, it can be passed here.
#' @param fullXtX Logical. If `TRUE`, include cross-condition terms in the
#'   h-update, meaning the design matrices for all conditions are used jointly
#'   when estimating the HRF coefficients. If `FALSE` (default), the HRF
#'   coefficients are estimated independently for each condition (though the
#'   same HRF shape `h` is assumed across conditions if not voxel-wise).
#'   The proposal indicates `fullXtX` is for the h-update.
#' @param max_alt Integer. The maximum number of alternations between the beta
#'   and h updates. The proposal notes that empirically one alternation
#'   (`max_alt = 1`) after SVD initialization is often sufficient.
#'   Defaults to 1.
#' @param ... Additional arguments passed to the underlying estimation engine.
#'
#' @return An object of class `fmrireg_cfals_fit`. This object contains:
#'   \itemize{
#'     \item `h`: A d x v matrix of HRF basis coefficients (d = number of basis functions, v = number of voxels).
#'     \item `beta`: A k x v matrix of condition amplitudes (k = number of conditions).
#'     \item `reconstructed_hrfs`: A p x v matrix of the actual HRF shapes (p = length of HRF, v = number of voxels), reconstructed using the `hrf_basis` and the estimated `h` coefficients.
#'     \item `residuals`: An n x v matrix of model residuals after fitting (n = number of timepoints).
#'     \item `hrf_basis_used`: The `hrf_basis` object that was supplied to the function.
#'     \item `lambdas_used`: A named list or vector containing the regularization parameters (`lam_beta`, `lam_h`) used in the estimation.
#'     \item `design_info`: A list containing dimensions and flags used during estimation (e.g., d, k, n, v, `fullXtX`).
#'     \item `gof_per_voxel`: Optional. Goodness-of-fit statistics per voxel, such as R-squared.
#'     \item (Other elements as defined by the `fmrireg_cfals_fit` class structure from the proposal, like `call`).
#'   }
#'
#' @details
#' This function implements the Confound-Free Alternating Least Squares (CF-ALS)
#' algorithm for data-driven estimation of Hemodynamic Response Functions (HRFs)
#' from fMRI data. It estimates HRF coefficients (`h`) and activation
#' amplitudes (`beta`) simultaneously using a rank-1 decomposition model:
#' Y ≈ D(h)β^T, where D(h) is the design matrix formed by convolving
#' stimulus onsets with the HRF (`h`).
#'
#' Key steps of the algorithm include:
#' \enumerate{
#'   \item Confound Projection: Nuisance regressors (if provided via `confound_obj`) are removed from both the BOLD data (Y) and the HRF basis design matrices (X.list) using QR-based orthogonal projection.
#'   \item Precomputation: Quantities like X^T X and X^T Y are precomputed for efficiency.
#'   \item SVD Initialization: Robust starting values for `h` and `beta` are obtained using a regularized least squares solution followed by Singular Value Decomposition (SVD) of the initial coefficient estimates. (This is handled by the main `fmrireg_cfals` function when `method="cf_als"`).
#'   \item CF-ALS Alternation: The algorithm alternates between updating `beta` (amplitudes) holding `h` (HRF coefficients) fixed, and updating `h` holding `beta` fixed. This process is repeated for `max_alt` iterations.
#'     \itemize{
#'       \item β-update: Solves (G_mat + λ_β I)β_v = D(h)^T y_v for each voxel v, where G_mat = D(h)^T D(h).
#'       \item h-update: Solves (LHS + λ_h I)h = RHS, where LHS and RHS depend on the data and current beta estimates. The `fullXtX` parameter influences the construction of LHS.
#'     }
#'   \item Identifiability: The estimated HRF coefficients `h` are typically normalized (e.g., ||Φh||_∞ = 1, where Φ is the basis reconstruction matrix) and their sign aligned with a canonical HRF shape to ensure consistent scaling and polarity across voxels/conditions.
#' }
#'
#' The function is designed to be compatible with any HRF basis defined in the
#' `fmrireg` package (provided `nbasis(hrf_basis) > 1`). The `R_mat`
#' parameter allows for basis-specific penalty matrices for HRF coefficient
#' regularization, although the default is an identity matrix (standard ridge penalty).
#'
#' R\eqn{^2} (coefficient of determination) is computed on the data *after*
#' any confound projection has been applied.
#'
#' @seealso [fmrireg_cfals()] for the more general wrapper allowing different estimation methods.
#' @references (If applicable, add references to papers describing the CF-ALS method or its implementation).
#'
#' @examples
#' # Simulate data
#' sframe <- fmrireg::sampling_frame(blocklens = 40, TR = 1)
#' ev_df <- data.frame(onset = c(5, 15, 25), block = 1, cond = "A")
#' emod <- fmrireg::event_model(onset ~ hrf(cond, basis = fmrireg::HRF_SPMG1),
#'                              data = ev_df, block = ~ block,
#'                              sampling_frame = sframe)
#' Y_matrix <- matrix(rnorm(40 * 5), 40, 5) # 40 timepoints, 5 voxels
#'
#' # Fit using fmrireg_hrf_cfals
#' cfals_fit <- fmrireg_hrf_cfals(
#'   fmri_data_obj = Y_matrix,
#'   event_model = emod,
#'   hrf_basis = fmrireg::HRF_SPMG1, # Using SPMG1 basis
#'   lam_beta = 5,
#'   lam_h = 0.5,
#'   max_alt = 1
#' )
#'
#' print(cfals_fit)
#' summary(cfals_fit) # If a summary method is defined
#' # plot(cfals_fit)    # If a plot method is defined
#'
#' # Example with B-spline basis
#' bspline_basis <- fmrireg::HRF_BSPLINE(knots = c(0, 4, 8, 12, 20))
#' emod_bspline <- fmrireg::event_model(onset ~ hrf(cond, basis = bspline_basis),
#'                                      data = ev_df, block = ~ block,
#'                                      sampling_frame = sframe)
#' cfals_fit_bspline <- fmrireg_hrf_cfals(
#'   fmri_data_obj = Y_matrix,
#'   event_model = emod_bspline,
#'   hrf_basis = bspline_basis,
#'   max_alt = 2
#' )
#' print(cfals_fit_bspline)
#'
#' @export
fmrireg_hrf_cfals <- function(fmri_data_obj,
                              event_model,
                              hrf_basis,
                              confound_obj = NULL,
                              lam_beta = 10,
                              lam_h = 1,
                              R_mat = NULL,
                              fullXtX = FALSE,
                              max_alt = 1,
                              ...) {
  fmrireg_cfals(fmri_data_obj,
                event_model,
                hrf_basis,
                confound_obj = confound_obj,
                method = "cf_als",
                lambda_b = lam_beta,
                lambda_h = lam_h,
                R_mat = R_mat,
                fullXtX = fullXtX,
                max_alt = max_alt,
                ...)
}
</file>

<file path="DESCRIPTION">
Package: hrfals
Title: HRF Estimation using Confound-Free Alternating Least Squares
Version: 0.0.0.9000
Authors@R: person("Bradley", "Buchsbauhm", email = "bradley.buchsbaum@utoronto.ca", role = c("aut", "cre"))
Description: Implements the Confound-Free Alternating Least Squares (CF-ALS) method for estimating hemodynamic response functions (HRFs) from fMRI data.
License: GPL-3
Encoding: UTF-8
RoxygenNote: 7.3.1 
Imports:
    fmrireg (>= 0.0.0.9000)
Remotes:
    bbuchsbaum/fmrireg
</file>

</files>
