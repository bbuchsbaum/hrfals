This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: R/**/*.R, R/**/*.r, *.Rmd, *.rmd, DESCRIPTION, tests/**/*.R, tests/**/*.r
- Files matching patterns in .gitignore are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
R/
  cf_als_engine.R
  cfals_design_utils_hrfals.R
  cfals_design_utils.R
  cfals_methods.R
  cfals_wrapper.R
  estimate_hrf_cfals.R
  hrfals_methods.R
  ls_svd_1als_engine.R
  ls_svd_engine.R
tests/
  testthat/
    test-cf_als_engine.R
    test-cfals_design_utils.R
    test-cfals-wrapper.R
    test-estimate_hrf_cfals.R
    test-hrfals_fit.R
    test-ls_svd_1als_engine.R
    test-ls_svd_engine.R
DESCRIPTION
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="R/cfals_design_utils.R">
#' CFALS Design Utilities
#'
#' Helper functions for interfacing the CF-ALS engine with the
#' fmrireg HRF basis system.
#'
#' @name cfals_design_utils
NULL

#' Reconstruction matrix for an HRF basis
#'
#' Returns a matrix \eqn{\Phi} that converts basis coefficients into a
#' sampled HRF shape.
#'
#' @param hrf An object of class `HRF`.
#' @param sframe A `sampling_frame` object or numeric vector of times.
#' @return A numeric matrix with one column per basis function.
#' @export
reconstruction_matrix <- function(hrf, sframe) {
  UseMethod("reconstruction_matrix")
}

#' @export
reconstruction_matrix.HRF <- function(hrf, sframe) {
  grid <- if (inherits(sframe, "sampling_frame")) {
    seq(0, attr(hrf, "span"), by = sframe$TR[1])
  } else {
    as.numeric(sframe)
  }
  vals <- evaluate(hrf, grid)
  if (is.vector(vals)) matrix(vals, ncol = 1L) else as.matrix(vals)
}

#' Penalty matrix for an HRF basis
#'
#' Provides a ridge or smoothness penalty matrix for the basis
#' coefficients. The default method returns an identity matrix.
#'
#' @param hrf An object of class `HRF`.
#' @return A square numeric matrix.
#' @export
penalty_matrix <- function(hrf) {
  UseMethod("penalty_matrix")
}

#' @export
penalty_matrix.HRF <- function(hrf) {
  diag(nbasis(hrf))
}

#' Convolve a timeseries with a single HRF basis function
#'
#' Utility helper that extracts one basis function from an `HRF` object and
#' performs discrete convolution with a raw timeseries.  The result has the
#' same length as the input series and is truncated to the sampling frame.
#'
#' @param ts Numeric vector of raw onset values.
#' @param hrf_basis An object of class `HRF` providing the basis set.
#' @param basis_index Integer index of the basis function to use.
#' @param sframe A `sampling_frame` object describing the temporal grid.
#' @return Numeric vector of convolved values.
#' @keywords internal
convolve_timeseries_with_single_basis <- function(ts, hrf_basis,
                                                  basis_index = 1, sframe) {
  if (!is.numeric(ts)) {
    stop("'ts' must be numeric")
  }
  if (!inherits(hrf_basis, "HRF")) {
    stop("'hrf_basis' must be an object of class 'HRF'")
  }
  nb <- fmrireg::nbasis(hrf_basis)
  if (basis_index < 1 || basis_index > nb) {
    stop("'basis_index' out of range")
  }

  grid <- if (inherits(sframe, "sampling_frame")) {
    seq(0, attr(hrf_basis, "span"), by = sframe$TR[1])
  } else {
    as.numeric(sframe)
  }
  vals <- fmrireg::evaluate(hrf_basis, grid)
  if (is.vector(vals)) vals <- matrix(vals, ncol = 1L)
  phi_j <- vals[, basis_index]

  conv_full <- stats::convolve(ts, rev(phi_j), type = "open")
  conv_full[seq_along(ts)]
}

#' Project design and data matrices to the null space of confounds
#'
#' Projects both the data matrix `Y` and each design matrix in
#' `X_list` using QR decomposition of the confound matrix.  The
#' projection can optionally use LAPACK's QR implementation for
#' improved numerical stability.
#'
#' @param Y Numeric matrix of BOLD data (time points \eqn{\times}
#'   voxels).
#' @param X_list A list of design matrices with the same number of
#'   rows as `Y`.
#' @param confounds Optional confound matrix with matching rows.
#' @param lapack_qr Logical; passed to `qr()` as the `LAPACK`
#'   argument.
#' @return A list with projected `X_list` and `Y` matrices.
#' @export
project_confounds <- function(Y, X_list, confounds = NULL, lapack_qr = TRUE) {
  if (is.null(confounds)) {
    return(list(X_list = X_list, Y = Y))
  }
  qrZ <- qr(confounds, LAPACK = lapack_qr)
  Xp <- lapply(X_list, function(X) qr.resid(qrZ, X))
  Yp <- qr.resid(qrZ, Y)
  list(X_list = Xp, Y = Yp)
}

#' Create design matrices for CFALS estimation
#'
#' Convenience helper that constructs the list of design matrices for
#' a given `event_model` and HRF basis.  It also returns useful
#' metadata such as the number of basis functions and conditions as
#' well as a reconstruction matrix for converting HRF coefficients to
#' sampled shapes and a normalised reference HRF vector for sign
#' alignment.
#'
#' @param event_model An object of class `event_model`.
#' @param hrf_basis An `HRF` basis object.
#' @return A list with elements `X_list`, `d`, `k`, `Phi`, and
#'   `h_ref_shape_norm`.
#' @export
create_fmri_design <- function(event_model, hrf_basis) {
  if (!inherits(event_model, "event_model")) {
    stop("'event_model' must be an 'event_model' object")
  }
  if (!inherits(hrf_basis, "HRF")) {
    stop("'hrf_basis' must be an object of class 'HRF'")
  }

  sframe <- event_model$sampling_frame
  sample_times <- samples(sframe, global = TRUE)

  reg_lists <- lapply(event_model$terms, regressors.event_term,
                      hrf = hrf_basis,
                      sampling_frame = sframe,
                      summate = FALSE,
                      drop.empty = TRUE)
  regs <- unlist(reg_lists, recursive = FALSE)
  cond_names <- names(regs)
  X_list <- lapply(regs, function(r)
    evaluate(r, sample_times, precision = sframe$precision))
  names(X_list) <- cond_names

  Phi <- reconstruction_matrix(hrf_basis, sframe)
  h_ref <- drop(Phi[, 1])
  h_ref <- h_ref / max(abs(h_ref))

  list(X_list = X_list,
       d = nbasis(hrf_basis),
       k = length(X_list),
       Phi = Phi,
       h_ref_shape_norm = h_ref)
}
</file>

<file path="R/cfals_methods.R">
#' Construct an \code{fmrireg_cfals_fit} object
#'
#' Simple constructor used by [fmrireg_cfals()] to package the
#' results returned by the various CFALS engines.
#'
#' @param h_coeffs Matrix of HRF basis coefficients (d \eqn{\times} v).
#' @param beta_amps Matrix of condition amplitudes (k \eqn{\times} v).
#' @param method Character string indicating the estimation method.
#' @param lambdas Numeric vector of regularisation parameters.
#' @param call The matched call to the wrapper function.
#' @param hrf_basis HRF basis object used for the estimation.
#' @param design_info List with design metadata (d, k, n, v, fullXtX).
#' @param residuals Residual matrix from the projected data fit.
#' @param recon_hrf Matrix of reconstructed HRF shapes.
#' @param gof Numeric vector of goodness-of-fit statistics per voxel.
#' @return An object of class \code{fmrireg_cfals_fit}.
#' @description
#' Container class storing the results of CFALS estimation.  Fields
#' include the HRF basis coefficients (`h_coeffs`), condition amplitudes
#' (`beta_amps`), details of the estimation method, regularisation
#' parameters and design information.
#'
#' @examples
#' \dontrun{
#' library(fmrireg)
#' 
#' # Create sampling frame and event model
#' sframe <- fmrireg::sampling_frame(blocklens = 40, TR = 1)
#' ev_df <- data.frame(onset = c(5, 15, 25), block = 1, cond = "A")
#' emod <- fmrireg::event_model(onset ~ hrf(cond), data = ev_df, 
#'                              block = ~ block, sampling_frame = sframe)
#' 
#' # Simulate some BOLD data
#' Y_matrix <- matrix(rnorm(40 * 5), 40, 5) # 40 timepoints, 5 voxels
#' 
#' # Fit using CF-ALS with SPMG3 basis (3 basis functions)
#' fit <- fmrireg_cfals(Y, emod, HRF_SPMG3)
#' print(fit)
#' }
#' @export
fmrireg_cfals_fit <- function(h_coeffs, beta_amps, method, lambdas, call,
                              hrf_basis, design_info, residuals,
                              recon_hrf = NULL, gof = NULL) {
  out <- list(h_coeffs = h_coeffs,
              beta_amps = beta_amps,
              method_used = method,
              lambdas = lambdas,
              call = call,
              hrf_basis_used = hrf_basis,
              design_info = design_info,
              residuals = residuals,
              reconstructed_hrfs = recon_hrf,
              gof_per_voxel = gof)
  class(out) <- c("fmrireg_cfals_fit", "list")
  out
}

#' Methods for fmrireg_cfals_fit Objects
#'
#' Basic utilities for inspecting the results
#' of `fmrireg_hrf_cfals`.
#'
#' @param x,object An `fmrireg_cfals_fit` object.
#' @param vox Index of the voxel to plot.
#' @param ... Additional arguments passed to underlying functions.
#' @export
print.fmrireg_cfals_fit <- function(x, ...) {
  cat("\nfmrireg CF-ALS Fit\n")
  cat("==================\n")
  info <- x$design_info
  cat(sprintf("Voxels: %d\n", info$v))
  cat(sprintf("Time points: %d\n", info$n))
  cat(sprintf("Conditions: %d\n", info$k))
  cat(sprintf("Basis functions: %d\n", info$d))
  invisible(x)
}

#' @export
summary.fmrireg_cfals_fit <- function(object, ...) {
  res <- list(r2 = object$gof_per_voxel,
              design = object$design_info,
              lambdas = object$lambdas)
  class(res) <- "summary.fmrireg_cfals_fit"
  res
}

#' @export
residuals.fmrireg_cfals_fit <- function(object, ...) {
  object$residuals
}

#' @export
plot.fmrireg_cfals_fit <- function(x, vox = 1, ...) {
  if (vox < 1 || vox > ncol(x$reconstructed_hrfs))
    stop("'vox' out of range")
  hrf <- x$reconstructed_hrfs[, vox]
  plot(hrf, type = "l", xlab = "Time index", ylab = "Amplitude",
       main = paste("Reconstructed HRF - voxel", vox), ...)
}
</file>

<file path="R/cfals_design_utils_hrfals.R">
#' Convolve timeseries with a single HRF basis function
#'
#' Helper that convolves a raw onset vector with the specified basis
#' function from an HRF object.
#'
#' @param raw_timeseries Numeric vector of length n.
#' @param hrf An object of class `HRF`.
#' @param basis_function_index Integer index of the basis function.
#' @param sampling_frame A `sampling_frame` describing the sampling grid.
#' @return Numeric vector of length n containing the convolved result.
#' @keywords internal
convolve_timeseries_with_single_basis <- function(raw_timeseries,
                                                  hrf,
                                                  basis_function_index,
                                                  sampling_frame) {
  stopifnot(inherits(hrf, "HRF"))
  nb <- nbasis(hrf)
  if (basis_function_index < 1 || basis_function_index > nb) {
    stop("basis_function_index out of range")
  }
  grid <- seq(0, attr(hrf, "span"), by = sampling_frame$TR[1])
  vals <- evaluate(hrf, grid)
  if (is.vector(vals)) {
    vals <- matrix(vals, ncol = 1L)
  }
  kern <- vals[, basis_function_index]
  conv_full <- convolve(raw_timeseries, rev(kern), type = "open")
  conv_full[seq_along(raw_timeseries)]
}

#' Create CFALS Design Matrices from fmrireg Objects
#'
#' This function leverages fmrireg's built-in design matrix creation and
#' HRF evaluation functionality to prepare inputs for CF-ALS estimation.
#' It uses the existing `create_fmri_design` function and adds CFALS-specific
#' processing.
#'
#' @param fmri_data_obj An `fmri_dataset` or numeric matrix of BOLD data.
#' @param event_model An `event_model` object from fmrireg.
#' @param hrf_basis An HRF basis object with `nbasis > 1`.
#' @param confound_obj Optional confound matrix.
#' @param hrf_shape_duration_sec Duration for the HRF reconstruction grid.
#' @param hrf_shape_sample_res_sec Sampling resolution for the HRF grid.
#' @return List with projected design matrices, reconstruction info and
#'   metadata for CFALS engines. Rows of `fmri_data_obj` containing `NA`
#'   in any voxel are zeroed out along with the corresponding rows in the
#'   design matrices and `confound_obj` (if provided). The indices of these
#'   rows are returned as `bad_row_idx`.
#' @export
create_cfals_design <- function(fmri_data_obj,
                               event_model,
                               hrf_basis,
                               confound_obj = NULL,
                               hrf_shape_duration_sec = attr(hrf_basis, "span"),
                               hrf_shape_sample_res_sec = event_model$sampling_frame$TR[1]) {
  
  # Extract BOLD data matrix
  if (inherits(fmri_data_obj, "fmri_dataset")) {
    Y_raw <- fmrireg::get_data_matrix(fmri_data_obj)
  } else if (is.matrix(fmri_data_obj)) {
    Y_raw <- fmri_data_obj
  } else {
    stop("'fmri_data_obj' must be an 'fmri_dataset' or matrix")
  }

  n_timepoints <- nrow(Y_raw)
  v_voxels <- ncol(Y_raw)
  
  # Handle missing data
  bad_row_idx <- which(apply(Y_raw, 1, function(r) any(is.na(r))))
  if (length(bad_row_idx) > 0) {
    Y_raw[bad_row_idx, ] <- 0
    if (!is.null(confound_obj)) {
      confound_obj[bad_row_idx, ] <- 0
    }
  }

  # Get basis dimensions
  d_basis_dim <- fmrireg::nbasis(hrf_basis)
  if (d_basis_dim <= 1) {
    stop("CF-ALS requires an hrf_basis with nbasis > 1")
  }

  # Use the existing create_fmri_design function
  design_info <- create_fmri_design(event_model, hrf_basis)
  
  X_list_raw <- design_info$X_list
  k_conditions <- design_info$k
  Phi_recon_matrix <- design_info$Phi
  
  # Handle missing data in design matrices
  if (length(bad_row_idx) > 0) {
    X_list_raw <- lapply(X_list_raw, function(X) {
      X[bad_row_idx, ] <- 0
      X
    })
  }
  
  # Get condition names
  cond_names <- names(X_list_raw)
  
  if (k_conditions == 0) {
    stop("No estimable conditions found in event model")
  }

  # Create canonical reference HRF using fmrireg's HRF_SPMG1
  time_points_for_shape <- seq(0, hrf_shape_duration_sec, by = hrf_shape_sample_res_sec)
  h_ref_shape_canonical <- fmrireg::evaluate(fmrireg::HRF_SPMG1, time_points_for_shape)
  h_ref_shape_canonical <- drop(h_ref_shape_canonical)
  h_ref_shape_canonical <- h_ref_shape_canonical / max(abs(h_ref_shape_canonical))

  # Project out confounds using the existing function
  proj <- project_confounds(Y_raw, X_list_raw, confound_obj)
  Y_proj <- proj$Y
  X_list_proj <- proj$X_list

  # Return comprehensive design information
  list(
    Y_proj = Y_proj,
    X_list_proj = X_list_proj,
    d_basis_dim = d_basis_dim,
    k_conditions = k_conditions,
    Phi_recon_matrix = Phi_recon_matrix,
    h_ref_shape_canonical = h_ref_shape_canonical,
    h_ref_shape_norm = design_info$h_ref_shape_norm,
    n_timepoints = n_timepoints,
    v_voxels = v_voxels,
    bad_row_idx = bad_row_idx,
    condition_names = cond_names,
    hrf_basis = hrf_basis,
    event_model = event_model,
    sampling_frame = event_model$sampling_frame,
    X_list = X_list_raw,
    d = d_basis_dim,
    k = k_conditions,
    Phi = Phi_recon_matrix
  )
}

#' Create CFALS Design from fmrireg Model
#'
#' Higher-level wrapper that creates CFALS design matrices from a complete
#' fmrireg model specification. This function leverages fmrireg's design
#' matrix creation more directly.
#'
#' @param fmri_model An `fmri_model` object from fmrireg.
#' @param fmri_data_obj An `fmri_dataset` or numeric matrix of BOLD data.
#' @param confound_obj Optional confound matrix.
#' @param target_terms Character vector of event term names to include.
#'   If NULL, all event terms are used.
#' @return List with design matrices and metadata for CFALS.
#' @export
create_cfals_design_from_model <- function(fmri_model,
                                          fmri_data_obj,
                                          confound_obj = NULL,
                                          target_terms = NULL) {
  
  # Extract BOLD data
  if (inherits(fmri_data_obj, "fmri_dataset")) {
    Y_raw <- fmrireg::get_data_matrix(fmri_data_obj)
  } else if (is.matrix(fmri_data_obj)) {
    Y_raw <- fmri_data_obj
  } else {
    stop("'fmri_data_obj' must be an 'fmri_dataset' or matrix")
  }

  # Get the full design matrix from fmrireg
  full_design <- fmrireg::design_matrix(fmri_model)
  
  # Extract event model and terms
  event_model <- fmri_model$event_model
  event_terms <- fmrireg::terms(event_model)
  
  # Filter terms if specified
  if (!is.null(target_terms)) {
    event_terms <- event_terms[target_terms]
    if (length(event_terms) == 0) {
      stop("No valid target terms found")
    }
  }
  
  # For now, we'll use the first event term that has an HRF basis
  # In the future, this could be extended to handle multiple terms
  hrf_term <- NULL
  hrf_basis <- NULL
  
  for (term_name in names(event_terms)) {
    term_obj <- event_terms[[term_name]]
    if (inherits(term_obj, "event_term")) {
      # Check if this term has an HRF specification
      # This is a simplified approach - in practice, we'd need to inspect
      # the term structure more carefully
      hrf_term <- term_obj
      # Extract HRF basis from the term (this would need to be implemented
      # based on the actual fmrireg term structure)
      break
    }
  }
  
  if (is.null(hrf_term)) {
    stop("No event term with HRF basis found in model")
  }
  
  # For now, fall back to the original approach
  # This would need to be refined based on the actual fmrireg model structure
  stop("create_cfals_design_from_model not fully implemented yet. Use create_cfals_design instead.")
}

#' Legacy function name for backward compatibility
#'
#' @param ... Arguments passed to create_cfals_design
#' @export
prepare_cfals_inputs_from_fmrireg_term <- function(...) {
  .Deprecated("create_cfals_design", 
              msg = "prepare_cfals_inputs_from_fmrireg_term is deprecated. Use create_cfals_design instead.")
  create_cfals_design(...)
}
</file>

<file path="R/hrfals_methods.R">
#' Construct an `hrfals_fit` object
#'
#' Simple constructor used by higher-level functions to package
#' the results returned by the various CFALS engines.
#'
#' @param h_coeffs Matrix of HRF basis coefficients (d x v).
#' @param beta_amps Matrix of condition amplitudes (k x v).
#' @param method Character string indicating the estimation method.
#' @param lambdas Numeric vector of regularisation parameters.
#' @param call The matched call to the wrapper function.
#' @param fmrireg_hrf_basis_used HRF basis object supplied to the wrapper.
#' @param design_info List with design metadata (d, k, n, v, fullXtX).
#' @param residuals Residual matrix from the projected data fit.
#' @param bad_row_idx Integer vector of time points that were zeroed due to NA
#'   values.
#' @param recon_hrf Matrix of reconstructed HRF shapes.
#' @param gof Numeric vector of goodness-of-fit statistics per voxel.
#' @return An object of class `hrfals_fit`.
#' @export
hrfals_fit <- function(h_coeffs, beta_amps, method, lambdas, call,
                       fmrireg_hrf_basis_used, target_event_term_name,
                       phi_recon_matrix, design_info, residuals,
                       bad_row_idx = integer(0),
                       recon_hrf = NULL, gof = NULL) {
  out <- list(h_coeffs = h_coeffs,
              beta_amps = beta_amps,
              method_used = method,
              lambdas = lambdas,
              call = call,
              fmrireg_hrf_basis_used = fmrireg_hrf_basis_used,
              target_event_term_name = target_event_term_name,
              phi_recon_matrix = phi_recon_matrix,
              design_info = design_info,
              residuals = residuals,
              bad_row_idx = bad_row_idx,
              reconstructed_hrfs = recon_hrf,
              gof_per_voxel = gof)
  class(out) <- c("hrfals_fit", "list")
  out
}

#' @export
print.hrfals_fit <- function(x, ...) {
  cat("\nhrfals Fit\n")
  cat("===========\n")
  info <- x$design_info
  cat(sprintf("Voxels: %d\n", info$v))
  cat(sprintf("Time points: %d\n", info$n))
  cat(sprintf("Conditions: %d\n", info$k))
  cat(sprintf("Basis functions: %d\n", info$d))
  if (!is.null(x$target_event_term_name))
    cat(sprintf("Target term: %s\n", x$target_event_term_name))
  invisible(x)
}

#' @export
summary.hrfals_fit <- function(object, ...) {
  res <- list(r2 = object$gof_per_voxel,
              design = object$design_info,
              lambdas = object$lambdas)
  class(res) <- "summary.hrfals_fit"
  res
}

#' @export
plot.hrfals_fit <- function(x, vox = 1, ...) {
  if (is.null(x$phi_recon_matrix))
    stop("phi_recon_matrix not available for plotting")
  if (vox < 1 || vox > ncol(x$h_coeffs))
    stop("'vox' out of range")
  hrf <- x$phi_recon_matrix %*% x$h_coeffs[, vox]
  plot(hrf, type = "l", xlab = "Time index", ylab = "Amplitude",
       main = paste("Reconstructed HRF - voxel", vox), ...)
  invisible(hrf)
}
</file>

<file path="tests/testthat/test-hrfals_fit.R">
context("hrfals_fit object")

test_that("hrfals_fit constructor works", {
  h <- matrix(rnorm(6), 3, 2)
  beta <- matrix(rnorm(4), 2, 2)
  phi <- matrix(rnorm(15), 5, 3)
  dinfo <- list(d = 3, k = 2, n = 5, v = 2)
  fit <- hrfals_fit(h, beta, "cf_als", c(beta = 1, h = 1),
                    fmrireg::HRF_SPMG3, "term", phi, dinfo, matrix(0,1,1))
  expect_s3_class(fit, "hrfals_fit")
  expect_equal(fit$h_coeffs, h)
  expect_equal(fit$beta_amps, beta)
})

test_that("print.hrfals_fit doesn't error", {
  h <- matrix(rnorm(6), 3, 2)
  beta <- matrix(rnorm(4), 2, 2)
  phi <- matrix(rnorm(15), 5, 3)
  dinfo <- list(d = 3, k = 2, n = 5, v = 2)
  fit <- hrfals_fit(h, beta, "cf_als", c(beta = 1, h = 1),
                    fmrireg::HRF_SPMG3, "term", phi, dinfo, matrix(0,1,1))
  expect_output(print(fit), "hrfals_fit")
})
</file>

<file path="tests/testthat/test-ls_svd_engine.R">
library(testthat)

context("ls_svd_engine")

simple_ls_svd_data <- function() {
  set.seed(123)
  n <- 50
  d <- 3
  k <- 2
  v <- 5
  h_true <- matrix(rnorm(d * v), d, v)
  beta_true <- matrix(rnorm(k * v), k, v)
  X_list <- lapply(seq_len(k), function(i) matrix(rnorm(n * d), n, d))
  Xbig <- do.call(cbind, X_list)
  Y <- Xbig %*% as.vector(matrix(h_true, d, v) %*% t(beta_true))
  Y <- matrix(Y, n, v)
  phi <- diag(d)
  href <- rep(1, nrow(phi))
  list(X_list = X_list, Y = Y, d = d, k = k,
       Phi = phi, href = href)
}


test_that("ls_svd_engine returns matrices with correct dimensions", {
  dat <- simple_ls_svd_data()
  res <- ls_svd_engine(dat$X_list, dat$Y,
                       lambda_init = 0,
                       Phi_recon_matrix = dat$Phi,
                       h_ref_shape_canonical = dat$href)
  expect_equal(dim(res$h), c(dat$d, ncol(dat$Y)))
  expect_equal(dim(res$beta), c(dat$k, ncol(dat$Y)))
  expect_equal(dim(res$Gamma_hat), c(dat$d * dat$k, ncol(dat$Y)))
})

test_that("ls_svd_engine supports custom penalty matrix", {
  dat <- simple_ls_svd_data()
  Rmat <- diag(dat$d) * 2
  res <- ls_svd_engine(dat$X_list, dat$Y,
                       lambda_init = 0.5,
                       Phi_recon_matrix = dat$Phi,
                       h_ref_shape_canonical = dat$href,
                       R_mat = Rmat)
  Xbig <- do.call(cbind, dat$X_list)
  XtX <- crossprod(Xbig)
  Xty <- crossprod(Xbig, dat$Y)
  bigR <- kronecker(diag(dat$k), Rmat)
  Gamma_manual <- solve(XtX + 0.5 * bigR, Xty)
  expect_equal(res$Gamma_hat, Gamma_manual)
})
</file>

<file path="tests/testthat/test-ls_svd_1als_engine.R">
library(testthat)

context("ls_svd_1als_engine")

simple_ls_svd_data <- function() {
  set.seed(123)
  n <- 50
  d <- 3
  k <- 2
  v <- 4
  h_true <- matrix(rnorm(d * v), d, v)
  beta_true <- matrix(rnorm(k * v), k, v)
  X_list <- lapply(seq_len(k), function(i) matrix(rnorm(n * d), n, d))
  Xbig <- do.call(cbind, X_list)
  Y <- Xbig %*% as.vector(matrix(h_true, d, v) %*% t(beta_true))
  Y <- matrix(Y, n, v)
  phi <- diag(d)
  href <- rep(1, nrow(phi))
  list(X_list = X_list, Y = Y, d = d, k = k,
       Phi = phi, href = href)
}

test_that("ls_svd_1als_engine returns matrices with correct dimensions", {
  dat <- simple_ls_svd_data()
  res <- ls_svd_1als_engine(dat$X_list, dat$Y,
                            lambda_init = 0,
                            lambda_b = 0.1,
                            lambda_h = 0.1,
                            Phi_recon_matrix = dat$Phi,
                            h_ref_shape_canonical = dat$href)
  expect_equal(dim(res$h), c(dat$d, ncol(dat$Y)))
  expect_equal(dim(res$beta), c(dat$k, ncol(dat$Y)))
  expect_equal(dim(res$h_ls_svd), c(dat$d, ncol(dat$Y)))
  expect_equal(dim(res$beta_ls_svd), c(dat$k, ncol(dat$Y)))
})

single_condition_data <- function() {
  set.seed(42)
  n <- 40
  d <- 2
  v <- 3
  X <- matrix(rnorm(n * d), n, d)
  h_true <- matrix(rnorm(d * v), d, v)
  b_true <- rnorm(v)
  Y <- (X %*% h_true) * matrix(rep(b_true, each = n), n, v)
  phi <- diag(d)
  href <- rep(1, nrow(phi))
  list(X_list = list(X), Y = Y, Phi = phi, href = href)
}

test_that("fullXtX_flag has no effect for single condition", {
  dat <- single_condition_data()
  res_diag <- ls_svd_1als_engine(dat$X_list, dat$Y,
                                 lambda_init = 0,
                                 lambda_b = 0.1,
                                 lambda_h = 0.1,
                                 fullXtX_flag = FALSE,
                                 Phi_recon_matrix = dat$Phi,
                                 h_ref_shape_canonical = dat$href)
  res_full <- ls_svd_1als_engine(dat$X_list, dat$Y,
                                 lambda_init = 0,
                                 lambda_b = 0.1,
                                 lambda_h = 0.1,
                                 fullXtX_flag = TRUE,
                                 Phi_recon_matrix = dat$Phi,
                                 h_ref_shape_canonical = dat$href)
  expect_equal(res_diag$h, res_full$h)
  expect_equal(res_diag$beta, res_full$beta)
})

correlated_data <- function() {
  set.seed(99)
  n <- 40
  d <- 2
  k <- 2
  v <- 2
  baseX <- matrix(rnorm(n * d), n, d)
  X_list <- list(baseX, baseX + matrix(rnorm(n * d, sd = 0.2), n, d))
  h_true <- matrix(rnorm(d * v), d, v)
  beta_true <- matrix(rnorm(k * v), k, v)
  Xbig <- do.call(cbind, X_list)
  Y <- Xbig %*% as.vector(matrix(h_true, d, v) %*% t(beta_true))
  Y <- matrix(Y, n, v)
  phi <- diag(d)
  href <- rep(1, nrow(phi))
  list(X_list = X_list, Y = Y, Phi = phi, href = href)
}

test_that("fullXtX_flag influences estimates when conditions correlate", {
  dat <- correlated_data()
  res_diag <- ls_svd_1als_engine(dat$X_list, dat$Y,
                                 lambda_init = 0,
                                 lambda_b = 0.1,
                                 lambda_h = 0.1,
                                 fullXtX_flag = FALSE,
                                 Phi_recon_matrix = dat$Phi,
                                 h_ref_shape_canonical = dat$href)
  res_full <- ls_svd_1als_engine(dat$X_list, dat$Y,
                                 lambda_init = 0,
                                 lambda_b = 0.1,
                                 lambda_h = 0.1,
                                 fullXtX_flag = TRUE,
                                 Phi_recon_matrix = dat$Phi,
                                 h_ref_shape_canonical = dat$href)
  expect_false(isTRUE(all.equal(res_diag$h, res_full$h)))
})
</file>

<file path="R/ls_svd_engine.R">
#' LS+SVD Rank-1 HRF Estimation Engine
#'
#' Internal helper implementing the LS+SVD algorithm described in
#' `data-raw/LSS+SVD_proposal.md`. The design matrices should already
#' be projected to the confound null space.
#'
#' @param X_list_proj list of k design matrices (n x d each)
#' @param Y_proj      numeric matrix of projected BOLD data (n x v)
#' @param lambda_init ridge penalty for initial GLM solve
#' @param Phi_recon_matrix Canonical reference HRF shape of length p for
#'   sign alignment
#' @param h_ref_shape_canonical Canonical reference HRF shape of length p for
#'   sign alignment
#' @param svd_backend currently ignored, placeholder for future backends
#' @param epsilon_svd tolerance for singular value screening
#' @param epsilon_scale tolerance for scale in identifiability step
#' @param R_mat optional penalty matrix for the initial GLM solve
#' @return list with matrices `h` (d x v), `beta` (k x v) and
#'         `Gamma_hat` (d*k x v)
#' @keywords internal
#' @noRd
ls_svd_engine <- function(X_list_proj, Y_proj, lambda_init = 1,
                          Phi_recon_matrix,
                          h_ref_shape_canonical,
                          svd_backend = c("base_R"),
                          epsilon_svd = 1e-8,
                          epsilon_scale = 1e-8,
                          R_mat = NULL) {
  svd_backend <- match.arg(svd_backend)
  stopifnot(is.list(X_list_proj), length(X_list_proj) >= 1)
  n <- nrow(Y_proj)
  v <- ncol(Y_proj)
  d <- ncol(X_list_proj[[1]])
  k <- length(X_list_proj)
  for (X in X_list_proj) {
    if (nrow(X) != n) stop("Design matrices must have same rows as Y_proj")
    if (ncol(X) != d) stop("All design matrices must have the same column count")
  }

  if (!is.matrix(Phi_recon_matrix) || ncol(Phi_recon_matrix) != d)
    stop("`Phi_recon_matrix` must be a p x d matrix")
  if (length(h_ref_shape_canonical) != nrow(Phi_recon_matrix))
    stop("`h_ref_shape_canonical` must have length nrow(Phi_recon_matrix)")

  if (!is.null(R_mat)) {
    if (!is.matrix(R_mat) || nrow(R_mat) != d || ncol(R_mat) != d) {
      stop(paste("R_mat must be a", d, "x", d, "matrix"))
    }
  }

  cholSolve <- function(M, B, eps = max(epsilon_svd, epsilon_scale)) {
    L <- tryCatch(chol(M),
                  error = function(e) chol(M + eps * diag(nrow(M))))
    backsolve(L, forwardsolve(t(L), B))
  }

  Xbig <- do.call(cbind, X_list_proj)
  XtX  <- crossprod(Xbig)
  Xty  <- crossprod(Xbig, Y_proj)
  penalty_mat <- if (is.null(R_mat)) diag(d) else R_mat
  R_big <- kronecker(diag(k), penalty_mat)
  XtX_ridge <- XtX + lambda_init * R_big
  Gamma_hat <- cholSolve(XtX_ridge, Xty)

  H_out <- matrix(0.0, d, v)
  B_out <- matrix(0.0, k, v)

  for (vx in seq_len(v)) {
    G_vx <- matrix(Gamma_hat[, vx], nrow = d, ncol = k)
    sv <- svd(G_vx, nu = 1, nv = 1)
    if (length(sv$d) && sv$d[1] > epsilon_svd) {
      s1 <- sqrt(sv$d[1])
      H_out[, vx] <- sv$u[, 1] * s1
      B_out[, vx] <- sv$v[, 1] * s1
    }
  }

  H_shapes <- Phi_recon_matrix %*% H_out
  scl <- apply(abs(H_shapes), 2, max)
  flip <- rep(1.0, v)
  align <- colSums(H_shapes * h_ref_shape_canonical)
  flip[align < 0 & scl > epsilon_scale] <- -1.0
  eff_scl <- pmax(scl, epsilon_scale)
  H_final <- sweep(H_out, 2, flip / eff_scl, "*")
  B_final <- sweep(B_out, 2, flip * eff_scl, "*")
  zero_idx <- scl <= epsilon_scale
  if (any(zero_idx)) {
    H_final[, zero_idx] <- 0
    B_final[, zero_idx] <- 0
  }

  dimnames(H_final) <- list(NULL, colnames(Y_proj))
  dimnames(B_final) <- list(names(X_list_proj), colnames(Y_proj))

  list(h = H_final, beta = B_final, Gamma_hat = Gamma_hat)
}
</file>

<file path="tests/testthat/test-cfals_design_utils.R">
context("cfals design helpers")

test_that("reconstruction_matrix works", {
  sf <- sampling_frame(10, TR = 1)
  phi <- reconstruction_matrix(HRF_SPMG3, sf)
  expect_equal(ncol(phi), nbasis(HRF_SPMG3))
  expect_gt(nrow(phi), 1)
})

test_that("penalty_matrix defaults to identity", {
  Rm <- penalty_matrix(HRF_SPMG3)
  expect_equal(Rm, diag(nbasis(HRF_SPMG3)))
})

test_that("convolve_timeseries_with_single_basis behaves like impulse response", {
  sf <- sampling_frame(10, TR = 1)
  raw_ts <- c(1, rep(0, 9))
  conv <- convolve_timeseries_with_single_basis(raw_ts, HRF_SPMG3, 2, sf)
  grid <- seq(0, attr(HRF_SPMG3, "span"), by = sf$TR[1])
  phi <- evaluate(HRF_SPMG3, grid)
  if (is.vector(phi)) phi <- matrix(phi, ncol = 1L)
  expect_equal(conv, phi[seq_along(raw_ts), 2])
})

test_that("project_confounds projects via QR", {
  X <- matrix(rnorm(20), 5, 4)
  Y <- matrix(rnorm(10), 5, 2)
  Z <- matrix(seq_len(5), ncol = 1)
  res <- project_confounds(Y, list(X), Z)
  expect_equal(dim(res$X_list[[1]]), dim(X))
  expect_equal(dim(res$Y), dim(Y))
})

test_that("create_fmri_design returns expected structure", {
  sf <- sampling_frame(20, TR = 1)
  events <- data.frame(onset = c(2, 6, 12),
                       condition = factor(c("A", "B", "A")),
                       block = 1)
  emod <- event_model(onset ~ hrf(condition), data = events,
                      block = ~ block, sampling_frame = sf)
  des <- create_fmri_design(emod, HRF_SPMG3)
  expect_type(des, "list")
  expect_equal(length(des$X_list), 2)
  expect_equal(des$d, nbasis(HRF_SPMG3))
  expect_equal(des$k, length(des$X_list))
  expect_true(is.matrix(des$Phi))
  expect_true(is.numeric(des$h_ref_shape_norm))
})

test_that("create_cfals_design returns expected structure", {
  sf <- sampling_frame(20, TR = 1)
  events <- data.frame(onset = c(2, 6, 12),
                       condition = factor(c("A", "B", "A")),
                       block = 1)
  emod <- event_model(onset ~ hrf(condition), data = events,
                      block = ~ block, sampling_frame = sf)
  Y <- matrix(rnorm(20 * 2), 20, 2)
  Z <- matrix(rnorm(20), ncol = 1)
  
  res <- create_cfals_design(Y, emod, HRF_SPMG3, Z,
                            hrf_shape_duration_sec = 16,
                            hrf_shape_sample_res_sec = 1)
  
  expect_type(res, "list")
  expect_equal(res$d_basis_dim, nbasis(HRF_SPMG3))
  expect_equal(res$k_conditions, 2)
  expect_equal(res$n_timepoints, 20)
  expect_equal(res$v_voxels, 2)
  expect_length(res$X_list_proj, 2)
  expect_true(is.matrix(res$Phi_recon_matrix))
  expect_true(is.numeric(res$h_ref_shape_canonical))
  expect_equal(length(res$condition_names), 2)
  
  # Check compatibility fields
  expect_equal(res$d, res$d_basis_dim)
  expect_equal(res$k, res$k_conditions)
  expect_equal(res$Phi, res$Phi_recon_matrix)
  expect_length(res$X_list, 2)
  expect_true(is.numeric(res$h_ref_shape_norm))
})

test_that("create_cfals_design zeroes NA rows", {
  sf <- sampling_frame(10, TR = 1)
  events <- data.frame(onset = c(1, 5),
                       condition = factor(c("A", "A")),
                       block = 1)
  emod <- event_model(onset ~ hrf(condition), data = events,
                      block = ~ block, sampling_frame = sf)
  Y <- matrix(rnorm(10 * 1), 10, 1)
  Y[3, ] <- NA

  res <- create_cfals_design(Y, emod, HRF_SPMG3)
  
  expect_equal(res$bad_row_idx, 3)
  expect_true(all(res$Y_proj[3, ] == 0))
  for (Xc in res$X_list_proj) {
    expect_true(all(Xc[3, ] == 0))
  }
})

test_that("create_cfals_design zeroes NA rows with confounds", {
  sf <- sampling_frame(10, TR = 1)
  events <- data.frame(onset = c(1, 5),
                       condition = factor(c("A", "A")),
                       block = 1)
  emod <- event_model(onset ~ hrf(condition), data = events,
                      block = ~ block, sampling_frame = sf)
  Y <- matrix(rnorm(10 * 1), 10, 1)
  Y[4, ] <- NA
  Z <- matrix(rnorm(10), ncol = 1)

  res <- create_cfals_design(Y, emod, HRF_SPMG3, Z)

  expect_equal(res$bad_row_idx, 4)
  expect_true(all(res$Y_proj[4, ] == 0))
  for (Xc in res$X_list_proj) {
    expect_true(all(Xc[4, ] == 0))
  }
})

test_that("create_cfals_design works without confounds", {
  sf <- sampling_frame(15, TR = 1)
  events <- data.frame(onset = c(2, 8),
                       condition = factor(c("A", "B")),
                       block = 1)
  emod <- event_model(onset ~ hrf(condition), data = events,
                      block = ~ block, sampling_frame = sf)
  Y <- matrix(rnorm(15 * 3), 15, 3)
  
  res <- create_cfals_design(Y, emod, HRF_SPMG2)
  
  expect_type(res, "list")
  expect_equal(res$d_basis_dim, nbasis(HRF_SPMG2))
  expect_equal(res$k_conditions, 2)
  expect_equal(res$n_timepoints, 15)
  expect_equal(res$v_voxels, 3)
  expect_length(res$X_list_proj, 2)
  expect_length(res$condition_names, 2)
  expect_true(all(c("A", "B") %in% res$condition_names))
})

test_that("deprecated function still works with warning", {
  sf <- sampling_frame(20, TR = 1)
  events <- data.frame(onset = c(2, 6, 12),
                       condition = factor(c("A", "B", "A")),
                       block = 1)
  emod <- event_model(onset ~ hrf(condition), data = events,
                      block = ~ block, sampling_frame = sf)
  Y <- matrix(rnorm(20 * 2), 20, 2)
  
  expect_warning(
    res <- prepare_cfals_inputs_from_fmrireg_term(Y, emod, HRF_SPMG3),
    "deprecated"
  )
  
  expect_type(res, "list")
  expect_equal(res$d_basis_dim, nbasis(HRF_SPMG3))
  expect_equal(res$k_conditions, 2)
})
</file>

<file path="DESCRIPTION">
Package: hrfals
Title: HRF Estimation using Confound-Free Alternating Least Squares
Version: 0.0.0.9000
Authors@R: person("Bradley", "Buchsbaum", email = "bradley.buchsbaum@utoronto.ca", role = c("aut", "cre"))
Description: Implements the Confound-Free Alternating Least Squares (CF-ALS) method for estimating hemodynamic response functions (HRFs) from fMRI data. The package provides fast, accurate, and robust alternatives for data-driven HRF estimation that work with any HRF basis from the fmrireg package.
License: GPL-3
Encoding: UTF-8
RoxygenNote: 7.3.1
Depends: 
    R (>= 3.5.0)
Imports:
    fmrireg (>= 0.0.0.9000),
    Matrix
Remotes:
    bbuchsbaum/fmrireg
URL: https://github.com/bbuchsbaum/hrfals
BugReports: https://github.com/bbuchsbaum/hrfals/issues
</file>

<file path="R/ls_svd_1als_engine.R">
#' LS+SVD+1ALS Rank-1 HRF Estimation Engine
#'
#' Internal helper implementing the LS+SVD+1ALS algorithm described in
#' `data-raw/LSS+SVD_proposal.md`. Inputs should be projected to the
#' confound null space.
#'
#' @param X_list_proj list of k design matrices (n x d each)
#' @param Y_proj numeric matrix of projected BOLD data (n x v)
#' @param lambda_init ridge penalty for initial GLM solve
#' @param lambda_b ridge penalty for \eqn{\beta}-update
#' @param lambda_h ridge penalty for \eqn{h}-update
#' @param fullXtX_flag logical; if TRUE use full cross-terms in h-update
#' @param Phi_recon_matrix Reconstruction matrix mapping coefficients to HRF
#'   shape (p x d)
#' @param h_ref_shape_canonical Canonical reference HRF shape of length p for
#'   sign alignment
#' @param svd_backend backend for SVD in the initialization step
#' @param epsilon_svd tolerance for singular value screening
#' @param epsilon_scale tolerance for scale in identifiability step
#' @param R_mat optional penalty matrix for the h-update
#' @return list with matrices `h` (d x v), `beta` (k x v) and the
#'         initial estimates `h_ls_svd`, `beta_ls_svd`
#' @keywords internal
#' @noRd
ls_svd_1als_engine <- function(X_list_proj, Y_proj,
                               lambda_init = 1,
                               lambda_b = 10,
                               lambda_h = 1,
                               fullXtX_flag = FALSE,
                               Phi_recon_matrix,
                               h_ref_shape_canonical,
                               svd_backend = c("base_R"),
                               epsilon_svd = 1e-8,
                               epsilon_scale = 1e-8,
                               R_mat = NULL) {

  if (lambda_init < 0 || lambda_b < 0 || lambda_h < 0)
    stop("Lambdas must be non-negative")
  stopifnot(is.list(X_list_proj), length(X_list_proj) >= 1)
  d <- ncol(X_list_proj[[1]])
  if (!is.matrix(Phi_recon_matrix) || ncol(Phi_recon_matrix) != d)
    stop("`Phi_recon_matrix` must be a p x d matrix")
  if (length(h_ref_shape_canonical) != nrow(Phi_recon_matrix))
    stop("`h_ref_shape_canonical` must have length nrow(Phi_recon_matrix)")

  if (!is.null(R_mat)) {
    if (!is.matrix(R_mat) || nrow(R_mat) != d || ncol(R_mat) != d) {
      stop(paste("R_mat must be a", d, "x", d, "matrix"))
    }
  }

  cholSolve <- function(M, B) {
    R <- tryCatch(chol(M),
                  error = function(e) chol(M + 1e-6 * diag(nrow(M))))
    backsolve(R, forwardsolve(t(R), B))
  }
  init <- ls_svd_engine(X_list_proj, Y_proj,
                        lambda_init = lambda_init,
                        Phi_recon_matrix = Phi_recon_matrix,
                        h_ref_shape_canonical = h_ref_shape_canonical,
                        svd_backend = svd_backend,
                        epsilon_svd = epsilon_svd,
                        epsilon_scale = epsilon_scale)

  h_current <- init$h
  b_current <- init$beta
  k <- length(X_list_proj)
  d <- ncol(X_list_proj[[1]])
  v <- ncol(Y_proj)

  XtX_list <- lapply(X_list_proj, crossprod)
  XtY_list <- lapply(X_list_proj, function(X) crossprod(X, Y_proj))

  XtX_full_list <- NULL
  if (fullXtX_flag) {
    XtX_full_list <- matrix(vector("list", k * k), k, k)
    for (l in seq_len(k)) {
      for (m in seq_len(k)) {
        XtX_full_list[[l, m]] <- crossprod(X_list_proj[[l]], X_list_proj[[m]])
      }
    }
  }

  H_als <- matrix(0.0, d, v)
  B_als <- matrix(0.0, k, v)

  for (vx in seq_len(v)) {
    h_vx <- h_current[, vx]
    DhTy_vx <- vapply(seq_len(k), function(c)
      crossprod(h_vx, XtY_list[[c]][, vx]), numeric(1))
    if (fullXtX_flag) {
      G_vx <- matrix(0.0, k, k)
      for (l in seq_len(k)) {
        for (m in seq_len(k)) {
          G_vx[l, m] <- crossprod(h_vx, XtX_full_list[[l, m]] %*% h_vx)
        }
      }
    } else {
      diag_vals <- vapply(seq_len(k), function(c)
        crossprod(h_vx, XtX_list[[c]] %*% h_vx), numeric(1))
      G_vx <- diag(diag_vals, k)
    }
    B_als[, vx] <- cholSolve(G_vx + lambda_b * diag(k), DhTy_vx)
  }

  b_current <- B_als

  for (vx in seq_len(v)) {
    b_vx <- b_current[, vx]
    penalty_mat <- if (is.null(R_mat)) diag(d) else R_mat
    lhs <- lambda_h * penalty_mat
    rhs <- numeric(d)
    for (l in seq_len(k)) {
      rhs <- rhs + b_vx[l] * XtY_list[[l]][, vx]
      if (fullXtX_flag) {
        for (m in seq_len(k)) {
          lhs <- lhs + b_vx[l] * b_vx[m] * XtX_full_list[[l, m]]
        }
      } else {
        lhs <- lhs + b_vx[l]^2 * XtX_list[[l]]
      }
    }
    H_als[, vx] <- cholSolve(lhs, rhs)
  }

  H_shapes_iter <- Phi_recon_matrix %*% H_als
  scl <- apply(abs(H_shapes_iter), 2, max)
  flip <- rep(1.0, v)
  align_scores <- colSums(H_shapes_iter * h_ref_shape_canonical)
  flip[align_scores < 0 & scl > epsilon_scale] <- -1.0
  eff_scl <- pmax(scl, epsilon_scale)
  H_final <- sweep(H_als, 2, flip / eff_scl, "*")
  B_final <- sweep(B_als, 2, flip * eff_scl, "*")
  zero_idx <- scl <= epsilon_scale
  if (any(zero_idx)) {
    H_final[, zero_idx] <- 0
    B_final[, zero_idx] <- 0
  }

  dimnames(H_final) <- list(NULL, colnames(Y_proj))
  dimnames(B_final) <- list(names(X_list_proj), colnames(Y_proj))

  list(h = H_final, beta = B_final,
       h_ls_svd = init$h, beta_ls_svd = init$beta)
}
</file>

<file path="tests/testthat/test-cfals-wrapper.R">
context("cfals wrapper")

library(fmrireg)

simulate_cfals_wrapper_data <- function(hrf_basis, noise_sd = 0.05, signal_scale = 1) {
  sf <- sampling_frame(blocklens = 60, TR = 1)
  events <- data.frame(
    onset = c(5, 15, 30, 45),
    condition = factor(c("A", "A", "B", "B")),
    block = 1
  )
  emod <- event_model(onset ~ hrf(condition), data = events,
                      block = ~ block, sampling_frame = sf)
  reg_lists <- lapply(emod$terms, regressors.event_term,
                      hrf = hrf_basis,
                      sampling_frame = sf,
                      summate = FALSE,
                      drop.empty = TRUE)
  regs <- unlist(reg_lists, recursive = FALSE)
  sample_times <- samples(sf, global = TRUE)
  X_list <- lapply(regs, function(r)
    evaluate(r, sample_times, precision = sf$precision))
  d <- nbasis(hrf_basis)
  k <- length(X_list)
  v <- 2
  h_true <- matrix(rnorm(d * v), d, v) * signal_scale
  beta_true <- matrix(rnorm(k * v), k, v) * signal_scale
  Y <- matrix(0, nrow(sample_times), v)
  for (c in seq_along(X_list)) {
    Y <- Y + (X_list[[c]] %*% h_true) *
      matrix(rep(beta_true[c, ], each = nrow(Y)), nrow(Y), v)
  }
  Y <- Y + matrix(rnorm(length(Y), sd = noise_sd), nrow(Y), v)
  attr(Y, "sampling_frame") <- sf
  list(Y = Y, event_model = emod, X_list = X_list,
       h_true = h_true, beta_true = beta_true, sframe = sf)
}


test_that("fmrireg_hrf_cfals works across HRF bases", {
  bases <- list(HRF_SPMG3, hrfspline_generator(nbasis = 4))
  for (b in bases) {
    dat <- simulate_cfals_wrapper_data(b)
    design <- create_cfals_design(dat$Y, dat$event_model, b)
    fit <- fmrireg_hrf_cfals(dat$Y, dat$event_model, b,
                             lam_beta = 0.1, lam_h = 0.1)
    expect_equal(dim(fit$h_coeffs), c(nbasis(b), ncol(dat$Y)))
    expect_equal(dim(fit$beta_amps), c(length(dat$X_list), ncol(dat$Y)))
    recon <- design$Phi_recon_matrix %*% fit$h_coeffs
    expect_true(all(is.finite(recon)))
  }
})

test_that("fmrireg_cfals wrapper supports multiple methods", {
  dat <- simulate_cfals_wrapper_data(HRF_SPMG3)
  methods <- c("ls_svd_only", "ls_svd_1als", "cf_als")
  for (m in methods) {
    fit <- fmrireg_cfals(dat$Y, dat$event_model, HRF_SPMG3,
                         method = m, lambda_b = 0.1, lambda_h = 0.1,
                         lambda_init = 0.5, max_alt = 1)
    expect_equal(dim(fit$h_coeffs), c(nbasis(HRF_SPMG3), ncol(dat$Y)))
    expect_equal(dim(fit$beta_amps), c(length(dat$X_list), ncol(dat$Y)))
  }
})

test_that("cfals handles low-signal data", {
  dat <- simulate_cfals_wrapper_data(HRF_SPMG3, noise_sd = 0.5, signal_scale = 0.01)
  fit <- fmrireg_hrf_cfals(dat$Y, dat$event_model, HRF_SPMG3)
  expect_lt(mean(fit$gof_per_voxel), 0.2)
})

simple_cfals_data_noise <- function() {
  set.seed(123)
  n <- 50
  d <- 3
  k <- 2
  v <- 3
  h_true <- matrix(rnorm(d * v), d, v)
  beta_true <- matrix(rnorm(k * v), k, v)
  X_list <- lapply(seq_len(k), function(i) matrix(rnorm(n * d), n, d))
  Xbig <- do.call(cbind, X_list)
  Y <- Xbig %*% as.vector(matrix(h_true, d, v) %*% t(beta_true))
  Y <- matrix(Y, n, v) + matrix(rnorm(n * v, sd = 0.01), n, v)
  phi <- diag(d)
  href <- rep(1, nrow(phi))
  list(X_list = X_list, Y = Y, Xbig = Xbig, Phi = phi, href = href)
}

test_that("cf_als_engine predictions match canonical GLM", {
  dat <- simple_cfals_data_noise()
  res <- cf_als_engine(dat$X_list, dat$Y,
                       lambda_b = 0,
                       lambda_h = 0,
                       R_mat_eff = NULL,
                       fullXtX_flag = FALSE,
                       precompute_xty_flag = TRUE,
                       Phi_recon_matrix = dat$Phi,
                       h_ref_shape_canonical = dat$href,
                       max_alt = 1)
  n <- nrow(dat$Y)
  v <- ncol(dat$Y)
  pred_cfals <- matrix(0, n, v)
  for (c in seq_along(dat$X_list)) {
    pred_cfals <- pred_cfals + (dat$X_list[[c]] %*% res$h) *
      matrix(rep(res$beta[c, ], each = n), n, v)
  }
  gamma_hat <- chol2inv(chol(crossprod(dat$Xbig))) %*% crossprod(dat$Xbig, dat$Y)
  pred_glm <- dat$Xbig %*% gamma_hat
  expect_equal(pred_cfals, pred_glm, tolerance = 1e-5)
})

test_that("fullXtX argument is forwarded through fmrireg_cfals", {
  dat <- simulate_cfals_wrapper_data(HRF_SPMG3)
  design <- create_cfals_design(dat$Y, dat$event_model, HRF_SPMG3)
  direct <- ls_svd_1als_engine(design$X_list_proj, design$Y_proj,
                               lambda_init = 0,
                               lambda_b = 0.1,
                               lambda_h = 0.1,
                               fullXtX_flag = TRUE,
                               Phi_recon_matrix = design$Phi_recon_matrix,
                               h_ref_shape_canonical = design$h_ref_shape_canonical)
  wrap <- fmrireg_cfals(dat$Y, dat$event_model, HRF_SPMG3,
                        method = "ls_svd_1als",
                        fullXtX = TRUE,
                        lambda_init = 0,
                        lambda_b = 0.1,
                        lambda_h = 0.1)
  expect_equal(wrap$h_coeffs, direct$h)
  expect_equal(wrap$beta_amps, direct$beta)
})

test_that("fmrireg_cfals predictions match canonical GLM", {
  set.seed(123)
  dat <- simulate_cfals_wrapper_data(HRF_SPMG3)
  fit <- fmrireg_cfals(dat$Y, dat$event_model, HRF_SPMG3,
                       method = "cf_als",
                       lambda_b = 0,
                       lambda_h = 0,
                       max_alt = 1)
  n <- nrow(dat$Y)
  v <- ncol(dat$Y)
  pred_cfals <- matrix(0, n, v)
  for (c in seq_along(dat$X_list)) {
    pred_cfals <- pred_cfals + (dat$X_list[[c]] %*% fit$h_coeffs) *
      matrix(rep(fit$beta_amps[c, ], each = n), n, v)
  }
  Xbig <- do.call(cbind, dat$X_list)
  gamma_hat <- chol2inv(chol(crossprod(Xbig))) %*% crossprod(Xbig, dat$Y)
  pred_glm <- Xbig %*% gamma_hat
  expect_equal(pred_cfals, pred_glm, tolerance = 1e-5)
})
</file>

<file path="R/cfals_wrapper.R">
#' Estimate Rank-1 HRF Using LS+SVD/CF-ALS Methods
#'
#' High level wrapper that prepares design matrices and dispatches to
#' the desired estimation engine.  This function supports the fast
#' \emph{LS+SVD} initialisation, the one-step refinement
#' \emph{LS+SVD+1ALS}, or the full alternating scheme implemented in
#' `cf_als_engine`.
#'
#' @param fmri_data_obj An `fmri_dataset` or numeric matrix of BOLD data
#'   (time points x voxels). If a dataset, sampling information is
#'   taken from the object.
#' @param event_model An `event_model` describing the stimuli to use
#'   for HRF estimation.
#' @param hrf_basis An `HRF` basis object used for the convolution
#'   design matrices.
#' @param confound_obj Optional matrix of confound regressors with the
#'   same number of rows as the data matrix.
#' @param method Estimation method. One of "ls_svd_only",
#'   "ls_svd_1als" (default) or "cf_als".
#' @param lambda_init Ridge penalty for the initial GLM solve used by
#'   `ls_svd` based methods.
#' @param lambda_b Ridge penalty for the beta update step.
#' @param lambda_h Ridge penalty for the h update step.
#' @param R_mat Optional penalty matrix for the h (HRF coefficient) update.
#'   If `NULL` (default), an identity matrix is used, corresponding to a simple
#'   ridge penalty. If a basis-specific penalty (e.g., for smoothing) is
#'   available from `hrf_basis`, it can be passed here.
#' @param fullXtX Logical; if `TRUE` include cross condition terms in
#'   the h update (where supported).
#' @param precompute_xty_flag Logical; passed to `cf_als_engine` to control
#'   precomputation of `XtY` matrices.
#' @param max_alt Number of alternating updates after initialisation
#'   when `method = "cf_als"`.
#' @param ... Additional arguments passed to the underlying estimation engine.
#' @return An object of class `fmrireg_cfals_fit` containing the
#'   estimated HRF coefficients and amplitudes.
#' @details
#' The `method` argument selects between the closed-form
#' \code{"ls_svd_only"}, the default \code{"ls_svd_1als"} which adds one
#' ALS refinement step, or the iterative \code{"cf_als"} engine.  The
#' ridge penalties \code{lambda_init}, \code{lambda_b} and
#' \code{lambda_h} control regularisation of the initial solve, the
#' beta-update and the h-update respectively.  Setting
#' \code{fullXtX = TRUE} includes cross-condition terms in the h-update
#' (when supported by the chosen engine).  R\eqn{^2} is computed on the
#' data after confound projection.
#'
#' @examples
#' \dontrun{
#' library(fmrireg)
#' 
#' # Create sampling frame and event model
#' sframe <- fmrireg::sampling_frame(blocklens = 40, TR = 1)
#' ev_df <- data.frame(onset = c(5, 15, 25), block = 1, cond = "A")
#' emod <- fmrireg::event_model(onset ~ hrf(cond), data = ev_df, 
#'                              block = ~ block, sampling_frame = sframe)
#' 
#' # Simulate some BOLD data
#' Y_matrix <- matrix(rnorm(40 * 5), 40, 5) # 40 timepoints, 5 voxels
#' 
#' # Fit using CF-ALS with SPMG3 basis (3 basis functions)
#' fit <- fmrireg_cfals(Y, emod, HRF_SPMG3)
#' print(fit)
#' }
#' @export
fmrireg_cfals <- function(fmri_data_obj,
                         event_model,
                         hrf_basis,
                         confound_obj = NULL,
                         method = c("ls_svd_1als", "ls_svd_only", "cf_als"),
                         lambda_init = 1,
                         lambda_b = 10,
                         lambda_h = 1,
                         R_mat = NULL,
                         fullXtX = FALSE,
                         precompute_xty_flag = TRUE,
                         max_alt = 1,
                         ...) {

  method <- match.arg(method)

  if (inherits(fmri_data_obj, "fmri_dataset")) {
    Y <- get_data_matrix(fmri_data_obj)
  } else if (is.matrix(fmri_data_obj)) {
    Y <- fmri_data_obj
  } else {
    stop("'fmri_data_obj' must be an 'fmri_dataset' or matrix")
  }

  sframe <- if (inherits(fmri_data_obj, "fmri_dataset"))
    fmri_data_obj$sampling_frame else attr(fmri_data_obj, "sampling_frame")

  if (is.null(sframe)) {
    stop("Sampling information could not be determined from input")
  }

  design <- create_cfals_design(fmri_data_obj,
                                event_model,
                                hrf_basis,
                                confound_obj = confound_obj)

  Xp <- design$X_list_proj
  Yp <- design$Y_proj
  cond_names <- design$condition_names

  fit <- switch(method,
    ls_svd_only = ls_svd_engine(Xp, Yp,
                                lambda_init = lambda_init,
                                h_ref_shape_norm = design$h_ref_shape_norm,
                                R_mat = R_mat, ...),
    ls_svd_1als = ls_svd_1als_engine(Xp, Yp,
                                     lambda_init = lambda_init,
                                     lambda_b = lambda_b,
                                     lambda_h = lambda_h,
                                     fullXtX_flag = fullXtX,
                                     h_ref_shape_norm = design$h_ref_shape_norm,
                                     R_mat = R_mat, ...),
    cf_als = cf_als_engine(Xp, Yp,
                           lambda_b = lambda_b,
                           lambda_h = lambda_h,
                           R_mat_eff = R_mat,
                           fullXtX_flag = fullXtX,
                           precompute_xty_flag = precompute_xty_flag,
                           h_ref_shape_norm = design$h_ref_shape_norm,
                           max_alt = max_alt, ...)
  )

  rownames(fit$beta) <- cond_names

  Phi <- design$Phi_recon_matrix
  recon_hrf <- Phi %*% fit$h

  n <- nrow(Yp)
  v <- ncol(Yp)
  k <- length(Xp)
  d <- nrow(fit$h)
  pred_p <- matrix(0, n, v)
  for (c in seq_len(k)) {
    pred_p <- pred_p + (Xp[[c]] %*% fit$h) *
      matrix(rep(fit$beta[c, ], each = n), n, v)
  }
  resids <- Yp - pred_p

  SST <- colSums((Yp - matrix(colMeans(Yp), n, v, TRUE))^2)
  SSE <- colSums(resids^2)
  r2 <- 1 - SSE / SST

  out <- fmrireg_cfals_fit(h_coeffs = fit$h,
                           beta_amps = fit$beta,
                           method = method,
                           lambdas = c(init = lambda_init,
                                       beta = lambda_b,
                                       h = lambda_h),
                           call = match.call(),
                           hrf_basis = hrf_basis,
                           design_info = list(d = design$d,
                                              k = design$k,
                                              n = n,
                                              v = v,
                                              fullXtX = fullXtX),
                           residuals = resids,
                           recon_hrf = recon_hrf,
                           gof = r2)
  out
}

#' Fit Rank-1 HRF Using CF-ALS
#'
#' Convenience wrapper for the original CF-ALS implementation.  This
#' function simply calls [fmrireg_cfals()] with `method = "cf_als"` and
#' retains the historical argument names.
#'
#' @param fmri_data_obj An `fmri_dataset` or numeric matrix of BOLD data
#'   (time points x voxels). If a dataset, sampling information is
#'   taken from the object.
#' @param event_model An `event_model` describing the stimuli to use
#'   for HRF estimation.
#' @param hrf_basis An `HRF` basis object from the `fmrireg` package
#'   (e.g., `HRF_BSPLINE`, `HRF_TENT`, `HRF_SPMG3`). This determines the
#'   set of basis functions used to model the HRF. The CF-ALS method
#'   can work with any basis where `nbasis > 1`.
#' @param confound_obj Optional numeric matrix of confound regressors (time
#'   points x number of confounds). These nuisance variables are projected
#'   out from the BOLD data and design matrices prior to CF-ALS estimation.
#'   Defaults to `NULL` (no confounds).
#' @param lam_beta Numeric. The regularization parameter for the beta (amplitude)
#'   update step. Controls the L2 penalty on the amplitude coefficients.
#'   Defaults to 10.
#' @param lam_h Numeric. The regularization parameter for the h (HRF coefficient)
#'   update step. Controls the L2 penalty on the HRF basis coefficients.
#'   Defaults to 1.
#' @param R_mat Optional penalty matrix for the h (HRF coefficient) update.
#'   If `NULL` (default), an identity matrix is used, corresponding to a simple
#'   ridge penalty. If a basis-specific penalty (e.g., for smoothing) is
#'   available from `hrf_basis`, it can be passed here.
#' @param fullXtX Logical. If `TRUE`, include cross-condition terms in the
#'   h-update, meaning the design matrices for all conditions are used jointly
#'   when estimating the HRF coefficients. If `FALSE` (default), the HRF
#'   coefficients are estimated independently for each condition (though the
#'   same HRF shape `h` is assumed across conditions if not voxel-wise).
#'   The proposal indicates `fullXtX` is for the h-update.
#' @param max_alt Integer. The maximum number of alternations between the beta
#'   and h updates. The proposal notes that empirically one alternation
#'   (`max_alt = 1`) after SVD initialization is often sufficient.
#'   Defaults to 1.
#' @param ... Additional arguments passed to the underlying estimation engine.
#'
#' @return An object of class `fmrireg_cfals_fit`. This object contains:
#'   \itemize{
#'     \item `h`: A d x v matrix of HRF basis coefficients (d = number of basis functions, v = number of voxels).
#'     \item `beta`: A k x v matrix of condition amplitudes (k = number of conditions).
#'     \item `reconstructed_hrfs`: A p x v matrix of the actual HRF shapes (p = length of HRF, v = number of voxels), reconstructed using the `hrf_basis` and the estimated `h` coefficients.
#'     \item `residuals`: An n x v matrix of model residuals after fitting (n = number of timepoints).
#'     \item `hrf_basis_used`: The `hrf_basis` object that was supplied to the function.
#'     \item `lambdas_used`: A named list or vector containing the regularization parameters (`lam_beta`, `lam_h`) used in the estimation.
#'     \item `design_info`: A list containing dimensions and flags used during estimation (e.g., d, k, n, v, `fullXtX`).
#'     \item `gof_per_voxel`: Optional. Goodness-of-fit statistics per voxel, such as R-squared.
#'     \item (Other elements as defined by the `fmrireg_cfals_fit` class structure from the proposal, like `call`).
#'   }
#'
#' @details
#' This function implements the Confound-Free Alternating Least Squares (CF-ALS)
#' algorithm for data-driven estimation of Hemodynamic Response Functions (HRFs)
#' from fMRI data. It estimates HRF coefficients (`h`) and activation
#' amplitudes (`beta`) simultaneously using a rank-1 decomposition model:
#' Y  D(h)^T, where D(h) is the design matrix formed by convolving
#' stimulus onsets with the HRF (`h`).
#'
#' Key steps of the algorithm include:
#' \enumerate{
#'   \item Confound Projection: Nuisance regressors (if provided via `confound_obj`) are removed from both the BOLD data (Y) and the HRF basis design matrices (X.list) using QR-based orthogonal projection.
#'   \item Precomputation: Quantities like X^T X and X^T Y are precomputed for efficiency.
#'   \item SVD Initialization: Robust starting values for `h` and `beta` are obtained using a regularized least squares solution followed by Singular Value Decomposition (SVD) of the initial coefficient estimates. (This is handled by the main `fmrireg_cfals` function when `method="cf_als"`).
#'   \item CF-ALS Alternation: The algorithm alternates between updating `beta` (amplitudes) holding `h` (HRF coefficients) fixed, and updating `h` holding `beta` fixed. This process is repeated for `max_alt` iterations.
#'     \itemize{
#'       \item -update: Solves (G_mat + _ I)_v = D(h)^T y_v for each voxel v, where G_mat = D(h)^T D(h).
#'       \item h-update: Solves (LHS + _h I)h = RHS, where LHS and RHS depend on the data and current beta estimates. The `fullXtX` parameter influences the construction of LHS.
#'     }
#'   \item Identifiability: The estimated HRF coefficients `h` are typically normalized (e.g., ||h||_ = 1, where  is the basis reconstruction matrix) and their sign aligned with a canonical HRF shape to ensure consistent scaling and polarity across voxels/conditions.
#' }
#'
#' The function is designed to be compatible with any HRF basis defined in the
#' `fmrireg` package (provided `nbasis(hrf_basis) > 1`). The `R_mat`
#' parameter allows for basis-specific penalty matrices for HRF coefficient
#' regularization, although the default is an identity matrix (standard ridge penalty).
#'
#' R\eqn{^2} (coefficient of determination) is computed on the data *after*
#' any confound projection has been applied.
#'
#' @seealso [fmrireg_cfals()] for the more general wrapper allowing different estimation methods.
#' @references (If applicable, add references to papers describing the CF-ALS method or its implementation).
#'
#' @examples
#' # Simulate data
#' sframe <- fmrireg::sampling_frame(blocklens = 40, TR = 1)
#' ev_df <- data.frame(onset = c(5, 15, 25), block = 1, cond = "A")
#' emod <- fmrireg::event_model(onset ~ hrf(cond, basis = fmrireg::HRF_SPMG3),
#'                              data = ev_df, block = ~ block,
#'                              sampling_frame = sframe)
#' Y_matrix <- matrix(rnorm(40 * 5), 40, 5) # 40 timepoints, 5 voxels
#'
#' # Fit using fmrireg_hrf_cfals
#' cfals_fit <- fmrireg_hrf_cfals(
#'   fmri_data_obj = Y_matrix,
#'   event_model = emod,
#'   hrf_basis = fmrireg::HRF_SPMG3, # Using SPMG3 basis (3 basis functions)
#'   lam_beta = 5,
#'   lam_h = 0.5,
#'   max_alt = 1
#' )
#'
#' print(cfals_fit)
#' summary(cfals_fit) # If a summary method is defined
#' # plot(cfals_fit)    # If a plot method is defined
#'
#' # Example with B-spline basis
#' bspline_basis <- fmrireg::HRF_BSPLINE(knots = c(0, 4, 8, 12, 20))
#' emod_bspline <- fmrireg::event_model(onset ~ hrf(cond, basis = bspline_basis),
#'                                      data = ev_df, block = ~ block,
#'                                      sampling_frame = sframe)
#' cfals_fit_bspline <- fmrireg_hrf_cfals(
#'   fmri_data_obj = Y_matrix,
#'   event_model = emod_bspline,
#'   hrf_basis = bspline_basis,
#'   max_alt = 2
#' )
#' print(cfals_fit_bspline)
#'
#' @export
fmrireg_hrf_cfals <- function(fmri_data_obj,
                              event_model,
                              hrf_basis,
                              confound_obj = NULL,
                              lam_beta = 10,
                              lam_h = 1,
                              R_mat = NULL,
                              fullXtX = FALSE,
                              max_alt = 1,
                              ...) {
  fmrireg_cfals(fmri_data_obj,
                event_model,
                hrf_basis,
                confound_obj = confound_obj,
                method = "cf_als",
                lambda_b = lam_beta,
                lambda_h = lam_h,
                R_mat = R_mat,
                fullXtX = fullXtX,
                max_alt = max_alt,
                ...)
}
</file>

<file path="R/estimate_hrf_cfals.R">
#' Estimate HRF for a target event term using CF-ALS
#'
#' High level wrapper around the CFALS engines operating on a single
#' `event_term` within an `fmrireg::event_model`. Design matrices and
#' projection are handled by `create_cfals_design`.
#'
#' @param fmri_data_obj `fmrireg::fmri_dataset` or numeric BOLD matrix.
#' @param fmrireg_event_model An `event_model` describing the full design.
#' @param target_event_term_name Name of the event_term to estimate.
#' @param hrf_basis_for_cfals An `HRF` object with `nbasis > 1`.
#' @param confound_obj Optional confound matrix.
#' @param method Estimation engine to use ("ls_svd_only", "ls_svd_1als", "cf_als").
#' @param lambda_init Ridge penalty for initial LS solve.
#' @param lambda_b Ridge penalty for the beta update.
#' @param lambda_h Ridge penalty for the h update.
#' @param penalty_R_mat_type How to construct the penalty matrix. One of
#'   "identity", "basis_default", or "custom". If "custom", supply `R_mat`.
#' @param R_mat Optional custom penalty matrix for the h update.
#' @param fullXtX Logical; passed to the estimation engine.
#' @param precompute_xty_flag Logical; passed to `cf_als_engine`.
#' @param max_alt Number of alternating updates for `cf_als`.
#' @param hrf_shape_duration Duration in seconds for reconstructed HRF grid.
#' @param hrf_shape_resolution Sampling resolution of the HRF grid.
#' @return An `hrfals_fit` object.
#' @export
estimate_hrf_cfals <- function(fmri_data_obj,
                               fmrireg_event_model,
                               target_event_term_name,
                               hrf_basis_for_cfals,
                               confound_obj = NULL,
                               method = c("ls_svd_1als", "ls_svd_only", "cf_als"),
                               lambda_init = 1,
                               lambda_b = 10,
                               lambda_h = 1,
                               penalty_R_mat_type = c("identity", "basis_default", "custom"),
                               R_mat = NULL,
                               fullXtX = FALSE,
                               precompute_xty_flag = TRUE,
                               max_alt = 1,
                               hrf_shape_duration = attr(hrf_basis_for_cfals, "span"),
                               hrf_shape_resolution = fmrireg_event_model$sampling_frame$TR[1],
                               ...) {
  method <- match.arg(method)
  penalty_R_mat_type <- match.arg(penalty_R_mat_type)

  prep <- create_cfals_design(fmri_data_obj,
                             fmrireg_event_model,
                             hrf_basis_for_cfals,
                             confound_obj = confound_obj,
                             hrf_shape_duration_sec = hrf_shape_duration,
                             hrf_shape_sample_res_sec = hrf_shape_resolution)

  Xp <- prep$X_list_proj
  Yp <- prep$Y_proj
  d <- prep$d_basis_dim
  k <- prep$k_conditions
  Phi <- prep$Phi_recon_matrix
  h_ref_shape_canonical <- prep$h_ref_shape_canonical
  n <- prep$n_timepoints
  v <- prep$v_voxels

  R_eff <- switch(penalty_R_mat_type,
                  identity = diag(d),
                  basis_default = penalty_matrix(hrf_basis_for_cfals),
                  custom = {
                    if (is.null(R_mat)) stop("R_mat must be supplied for custom penalty")
                    R_mat
                  })

  fit <- switch(method,
    ls_svd_only = ls_svd_engine(Xp, Yp,
                                lambda_init = lambda_init,
                                Phi_recon_matrix = Phi,
                                h_ref_shape_canonical = h_ref_shape_canonical,
                                R_mat = R_eff),
    ls_svd_1als = ls_svd_1als_engine(Xp, Yp,
                                     lambda_init = lambda_init,
                                     lambda_b = lambda_b,
                                     lambda_h = lambda_h,
                                     fullXtX_flag = fullXtX,
                                     Phi_recon_matrix = Phi,
                                     h_ref_shape_canonical = h_ref_shape_canonical,
                                     R_mat = R_eff),
    cf_als = cf_als_engine(Xp, Yp,
                           lambda_b = lambda_b,
                           lambda_h = lambda_h,
                           R_mat_eff = R_eff,
                           fullXtX_flag = fullXtX,
                           precompute_xty_flag = precompute_xty_flag,
                           Phi_recon_matrix = Phi,
                           h_ref_shape_canonical = h_ref_shape_canonical,
                           max_alt = max_alt)
  )

  rownames(fit$beta) <- prep$condition_names
  recon_hrf <- Phi %*% fit$h

  pred_p <- matrix(0, n, v)
  for (c in seq_len(k)) {
    pred_p <- pred_p + (Xp[[c]] %*% fit$h) *
      matrix(rep(fit$beta[c, ], each = n), n, v)
  }
  resids <- Yp - pred_p

  SST <- colSums((Yp - matrix(colMeans(Yp), n, v, TRUE))^2)
  SSE <- colSums(resids^2)
  r2 <- 1 - SSE / SST

  hrfals_fit(h_coeffs = fit$h,
             beta_amps = fit$beta,
             method = method,
             lambdas = c(init = lambda_init,
                         beta = lambda_b,
                         h = lambda_h),
             call = match.call(),
             fmrireg_hrf_basis_used = hrf_basis_for_cfals,
             target_event_term_name = target_event_term_name,
             phi_recon_matrix = Phi,
             design_info = list(d = d, k = k, n = n, v = v, fullXtX = fullXtX),
             residuals = resids,
             bad_row_idx = prep$bad_row_idx,
             recon_hrf = recon_hrf,
             gof = r2)
}
</file>

<file path="tests/testthat/test-cf_als_engine.R">
context("cf_als_engine")

simple_cfals_data <- function() {
  set.seed(123)
  n <- 50
  d <- 3
  k <- 2
  v <- 4
  h_true <- matrix(rnorm(d * v), d, v)
  beta_true <- matrix(rnorm(k * v), k, v)
  X_list <- lapply(seq_len(k), function(i) matrix(rnorm(n * d), n, d))
  Xbig <- do.call(cbind, X_list)
  Y <- Xbig %*% as.vector(matrix(h_true, d, v) %*% t(beta_true))
  Y <- matrix(Y, n, v)
  phi <- diag(d)
  href <- rep(1, nrow(phi))
  list(X_list = X_list, Y = Y, d = d, k = k,
       Phi = phi, href = href)
}

test_that("cf_als_engine returns matrices with correct dimensions", {
  dat <- simple_cfals_data()
  res <- cf_als_engine(dat$X_list, dat$Y,
                       lambda_b = 0.1,
                       lambda_h = 0.1,
                       R_mat_eff = NULL,
                       fullXtX_flag = FALSE,
                       precompute_xty_flag = TRUE,
                       Phi_recon_matrix = dat$Phi,
                       h_ref_shape_canonical = dat$href,
                       max_alt = 1)
  expect_equal(dim(res$h), c(dat$d, ncol(dat$Y)))
  expect_equal(dim(res$beta), c(dat$k, ncol(dat$Y)))
})


simple_small_data <- function() {
  set.seed(42)
  n <- 20; d <- 2; k <- 2; v <- 2
  h_true <- matrix(rnorm(d * v), d, v)
  beta_true <- matrix(rnorm(k * v), k, v)
  X_list <- lapply(seq_len(k), function(i) matrix(rnorm(n * d), n, d))
  Y <- matrix(0, n, v)
  for (c in seq_len(k)) {
    Y <- Y + (X_list[[c]] %*% h_true) *
      matrix(rep(beta_true[c, ], each = n), n, v)
  }
  phi <- diag(d)
  href <- rep(1, nrow(phi))
  list(X_list = X_list, Y = Y, Phi = phi, href = href)
}

test_that("XtY strategies give identical results", {
  dat <- simple_small_data()
  Rm <- diag(2) * 1.5
  res_pre <- cf_als_engine(dat$X_list, dat$Y,
                           lambda_b = 0.1,
                           lambda_h = 0.2,
                           R_mat_eff = Rm,
                           fullXtX_flag = FALSE,
                           precompute_xty_flag = TRUE,
                           Phi_recon_matrix = dat$Phi,
                           h_ref_shape_canonical = dat$href,
                           max_alt = 1)
  res_onfly <- cf_als_engine(dat$X_list, dat$Y,
                             lambda_b = 0.1,
                             lambda_h = 0.2,
                             R_mat_eff = Rm,
                             fullXtX_flag = FALSE,
                             precompute_xty_flag = FALSE,
                             Phi_recon_matrix = dat$Phi,
                             h_ref_shape_canonical = dat$href,
                             max_alt = 1)
  expect_equal(res_pre$h, res_onfly$h, tolerance = 1e-12)
  expect_equal(res_pre$beta, res_onfly$beta, tolerance = 1e-12)
})

test_that("XtY strategies match with fullXtX", {
  dat <- simple_small_data()
  Rm <- diag(2) * 1.5
  res_pre <- cf_als_engine(dat$X_list, dat$Y,
                           lambda_b = 0.1,
                           lambda_h = 0.2,
                           R_mat_eff = Rm,
                           fullXtX_flag = TRUE,
                           precompute_xty_flag = TRUE,
                           Phi_recon_matrix = dat$Phi,
                           h_ref_shape_canonical = dat$href,
                           max_alt = 1)
  res_onfly <- cf_als_engine(dat$X_list, dat$Y,
                             lambda_b = 0.1,
                             lambda_h = 0.2,
                             R_mat_eff = Rm,
                             fullXtX_flag = TRUE,
                             precompute_xty_flag = FALSE,
                             Phi_recon_matrix = dat$Phi,
                             h_ref_shape_canonical = dat$href,
                             max_alt = 1)
  expect_equal(res_pre$h, res_onfly$h, tolerance = 1e-12)
  expect_equal(res_pre$beta, res_onfly$beta, tolerance = 1e-12)
})

test_that("precompute_xty_flag FALSE reproduces TRUE", {
  dat <- simple_cfals_data()
  res_true <- cf_als_engine(dat$X_list, dat$Y,
                            lambda_b = 0.1,
                            lambda_h = 0.1,
                            fullXtX_flag = FALSE,
                            max_alt = 1,
                            precompute_xty_flag = TRUE,
                            Phi_recon_matrix = dat$Phi,
                            h_ref_shape_canonical = dat$href)
  res_false <- cf_als_engine(dat$X_list, dat$Y,
                             lambda_b = 0.1,
                             lambda_h = 0.1,
                             fullXtX_flag = FALSE,
                             max_alt = 1,
                             precompute_xty_flag = FALSE,
                             Phi_recon_matrix = dat$Phi,
                             h_ref_shape_canonical = dat$href)
  expect_equal(res_false$h, res_true$h)
  expect_equal(res_false$beta, res_true$beta)
})


test_that("h_ref_shape_canonical length must equal p", {
  dat <- simple_cfals_data()
  bad_ref <- numeric(nrow(dat$Phi) + 1)
  expect_error(
    cf_als_engine(dat$X_list, dat$Y,
                  Phi_recon_matrix = dat$Phi,
                  h_ref_shape_canonical = bad_ref),
    "`h_ref_shape_canonical` must have length"
  )
})
          
test_that("size estimate uses numeric arithmetic", {
  k <- .Machine$integer.max
  d <- 2L
  v <- 1L
  size_est <- as.numeric(k) * d * v * 8
  expect_true(is.finite(size_est))
  expect_gt(size_est, 2e9)

})



# Additional multi-voxel test to ensure on-the-fly XtY matches precomputed
multi_voxel_data <- function() {
  set.seed(66)
  n <- 30; d <- 2; k <- 2; v <- 3
  h_true <- matrix(rnorm(d * v), d, v)
  beta_true <- matrix(rnorm(k * v), k, v)
  X_list <- lapply(seq_len(k), function(i) matrix(rnorm(n * d), n, d))
  Y <- matrix(0, n, v)
  for (c in seq_len(k)) {
    Y <- Y + (X_list[[c]] %*% h_true) *
      matrix(rep(beta_true[c, ], each = n), n, v)
  }
  phi <- diag(2)
  href <- rep(1, nrow(phi))
  list(X_list = X_list, Y = Y, Phi = phi, href = href)
}

test_that("XtY cache recomputed per voxel when precomputing disabled", {
  dat <- multi_voxel_data()
  res_true <- cf_als_engine(dat$X_list, dat$Y,
                            lambda_b = 0.1,
                            lambda_h = 0.2,
                            precompute_xty_flag = TRUE,
                            Phi_recon_matrix = dat$Phi,
                            h_ref_shape_canonical = dat$href,
                            max_alt = 1)
  res_false <- cf_als_engine(dat$X_list, dat$Y,
                             lambda_b = 0.1,
                             lambda_h = 0.2,
                             precompute_xty_flag = FALSE,
                             Phi_recon_matrix = dat$Phi,
                             h_ref_shape_canonical = dat$href,
                             max_alt = 1)
  expect_equal(res_false$h, res_true$h, tolerance = 1e-12)
  expect_equal(res_false$beta, res_true$beta, tolerance = 1e-12)
})
                   
test_that("non-symmetric R_mat_eff is forced symmetric", {
  dat <- simple_small_data()
  Rm_nonsym <- matrix(c(1, 2, 3, 4), 2, 2)
  res_nonsym <- cf_als_engine(dat$X_list, dat$Y,
                              lambda_b = 0.1,
                              lambda_h = 0.2,
                              R_mat_eff = Rm_nonsym,
                              fullXtX_flag = FALSE,
                              precompute_xty_flag = TRUE,
                              Phi_recon_matrix = dat$Phi,
                              h_ref_shape_canonical = dat$href,
                              max_alt = 1)
  Rm_sym <- Matrix::forceSymmetric(Rm_nonsym)
  res_sym <- cf_als_engine(dat$X_list, dat$Y,
                           lambda_b = 0.1,
                           lambda_h = 0.2,
                           R_mat_eff = Rm_sym,
                           fullXtX_flag = FALSE,
                           precompute_xty_flag = TRUE,
                           Phi_recon_matrix = dat$Phi,
                           h_ref_shape_canonical = dat$href,
                           max_alt = 1)
  expect_equal(res_nonsym$h, res_sym$h)
  expect_equal(res_nonsym$beta, res_sym$beta)

})
</file>

<file path="tests/testthat/test-estimate_hrf_cfals.R">
context("estimate_hrf_cfals wrapper")

library(fmrireg)

simulate_cfals_wrapper_data <- function(hrf_basis, noise_sd = 0.05, signal_scale = 1) {
  sf <- sampling_frame(blocklens = 60, TR = 1)
  events <- data.frame(
    onset = c(5, 15, 30, 45),
    condition = factor(c("A", "A", "B", "B")),
    block = 1
  )
  emod <- event_model(onset ~ hrf(condition), data = events,
                      block = ~ block, sampling_frame = sf)
  reg_lists <- lapply(emod$terms, regressors.event_term,
                      hrf = hrf_basis,
                      sampling_frame = sf,
                      summate = FALSE,
                      drop.empty = TRUE)
  regs <- unlist(reg_lists, recursive = FALSE)
  sample_times <- samples(sf, global = TRUE)
  X_list <- lapply(regs, function(r)
    evaluate(r, sample_times, precision = sf$precision))
  d <- nbasis(hrf_basis)
  k <- length(X_list)
  v <- 2
  h_true <- matrix(rnorm(d * v), d, v) * signal_scale
  beta_true <- matrix(rnorm(k * v), k, v) * signal_scale
  Y <- matrix(0, nrow(sample_times), v)
  for (c in seq_along(X_list)) {
    Y <- Y + (X_list[[c]] %*% h_true) *
      matrix(rep(beta_true[c, ], each = nrow(Y)), nrow(Y), v)
  }
  Y <- Y + matrix(rnorm(length(Y), sd = noise_sd), nrow(Y), v)
  attr(Y, "sampling_frame") <- sf
  list(Y = Y, event_model = emod, X_list = X_list,
       h_true = h_true, beta_true = beta_true, sframe = sf)
}


test_that("estimate_hrf_cfals returns expected dimensions", {
  dat <- simulate_cfals_wrapper_data(HRF_SPMG3)
  fit <- estimate_hrf_cfals(dat$Y, dat$event_model, "hrf(condition)", HRF_SPMG3,
                            lambda_b = 0.1, lambda_h = 0.1)
  expect_s3_class(fit, "hrfals_fit")
  expect_equal(dim(fit$h_coeffs), c(nbasis(HRF_SPMG3), ncol(dat$Y)))
  expect_equal(dim(fit$beta_amps), c(2, ncol(dat$Y)))
  expect_equal(rownames(fit$beta_amps), c("conditionA", "conditionB"))
  expect_equal(fit$target_event_term_name, "hrf(condition)")
  expect_true(is.matrix(fit$phi_recon_matrix))
})

test_that("estimate_hrf_cfals carries bad_row_idx", {
  dat <- simulate_cfals_wrapper_data(HRF_SPMG3)
  dat$Y[4, 1] <- NA
  fit <- estimate_hrf_cfals(dat$Y, dat$event_model, "hrf(condition)", HRF_SPMG3,
                            lambda_b = 0.1, lambda_h = 0.1)
  expect_equal(fit$bad_row_idx, 4)
})


test_that("estimate_hrf_cfals matches direct ls_svd_1als", {
  dat <- simulate_cfals_wrapper_data(HRF_SPMG3)
  prep <- create_cfals_design(dat$Y, dat$event_model, HRF_SPMG3)
  direct <- ls_svd_1als_engine(prep$X_list_proj, prep$Y_proj,
                               lambda_init = 0,
                               lambda_b = 0.1,
                               lambda_h = 0.1,
                               fullXtX_flag = TRUE,
                               Phi_recon_matrix = prep$Phi_recon_matrix,
                               h_ref_shape_canonical = prep$h_ref_shape_canonical,
                               R_mat = diag(prep$d_basis_dim))
  wrap <- estimate_hrf_cfals(dat$Y, dat$event_model, "hrf(condition)", HRF_SPMG3,
                             method = "ls_svd_1als",
                             lambda_init = 0,
                             lambda_b = 0.1,
                             lambda_h = 0.1,
                             fullXtX = TRUE,
                             penalty_R_mat_type = "identity")
  expect_equal(wrap$h_coeffs, direct$h)
  expect_equal(wrap$beta_amps, direct$beta)
})


test_that("estimate_hrf_cfals predictions match canonical GLM", {
  set.seed(123)
  dat <- simulate_cfals_wrapper_data(HRF_SPMG3)
  fit <- estimate_hrf_cfals(dat$Y, dat$event_model, "hrf(condition)",
                            HRF_SPMG3,
                            method = "cf_als",
                            lambda_b = 0,
                            lambda_h = 0,
                            max_alt = 1)
  n <- nrow(dat$Y)
  v <- ncol(dat$Y)
  pred_cfals <- matrix(0, n, v)
  for (c in seq_along(dat$X_list)) {
    pred_cfals <- pred_cfals + (dat$X_list[[c]] %*% fit$h_coeffs) *
      matrix(rep(fit$beta_amps[c, ], each = n), n, v)
  }
  Xbig <- do.call(cbind, dat$X_list)
  gamma_hat <- chol2inv(chol(crossprod(Xbig))) %*% crossprod(Xbig, dat$Y)
  pred_glm <- Xbig %*% gamma_hat
  expect_equal(pred_cfals, pred_glm, tolerance = 1e-5)
})
                   
test_that("penalty_R_mat_type 'basis' uses basis penalty matrix", {
  dat <- simulate_cfals_wrapper_data(HRF_SPMG3)
  prep <- create_cfals_design(dat$Y, dat$event_model, HRF_SPMG3)
  Rb <- penalty_matrix(HRF_SPMG3)
  direct <- ls_svd_1als_engine(prep$X_list_proj, prep$Y_proj,
                               lambda_init = 0,
                               lambda_b = 0.1,
                               lambda_h = 0.1,
                               fullXtX_flag = TRUE,
                               Phi_recon_matrix = prep$Phi_recon_matrix,
                               h_ref_shape_canonical = prep$h_ref_shape_canonical,
                               R_mat = Rb)
  wrap <- estimate_hrf_cfals(dat$Y, dat$event_model, "hrf(condition)", HRF_SPMG3,
                             method = "ls_svd_1als",
                             lambda_init = 0,
                             lambda_b = 0.1,
                             lambda_h = 0.1,
                             fullXtX = TRUE,
                             penalty_R_mat_type = "basis")
  expect_equal(wrap$h_coeffs, direct$h)
  expect_equal(wrap$beta_amps, direct$beta)
})

test_that("penalty_R_mat_type 'custom' uses provided matrix", {
  dat <- simulate_cfals_wrapper_data(HRF_SPMG3)
  prep <- create_cfals_design(dat$Y, dat$event_model, HRF_SPMG3)
  R_custom <- diag(prep$d_basis_dim) * 2
  direct <- ls_svd_1als_engine(prep$X_list_proj, prep$Y_proj,
                               lambda_init = 0,
                               lambda_b = 0.1,
                               lambda_h = 0.1,
                               fullXtX_flag = TRUE,
                               Phi_recon_matrix = prep$Phi_recon_matrix,
                               h_ref_shape_canonical = prep$h_ref_shape_canonical,
                               R_mat = R_custom)
  wrap <- estimate_hrf_cfals(dat$Y, dat$event_model, "hrf(condition)", HRF_SPMG3,
                             method = "ls_svd_1als",
                             lambda_init = 0,
                             lambda_b = 0.1,
                             lambda_h = 0.1,
                             fullXtX = TRUE,
                             penalty_R_mat_type = "custom",
                             R_mat = R_custom)
  expect_equal(wrap$h_coeffs, direct$h)
  expect_equal(wrap$beta_amps, direct$beta)

})


simulate_multiterm_data <- function(hrf_basis, noise_sd = 0.05) {
  sf <- sampling_frame(blocklens = 60, TR = 1)
  events <- data.frame(
    onset = c(5, 15, 25, 35),
    term1 = factor(c("A", "A", "B", "B")),
    term2 = factor(c("C", "D", "C", "D")),
    block = 1
  )
  emod <- event_model(onset ~ hrf(term1) + hrf(term2), data = events,
                      block = ~ block, sampling_frame = sf)
  reg_lists <- lapply(emod$terms, regressors.event_term,
                      hrf = hrf_basis,
                      sampling_frame = sf,
                      summate = FALSE,
                      drop.empty = TRUE)
  regs <- unlist(reg_lists, recursive = FALSE)
  sample_times <- samples(sf, global = TRUE)
  X_list <- lapply(regs, function(r)
    evaluate(r, sample_times, precision = sf$precision))
  d <- nbasis(hrf_basis)
  k <- length(X_list)
  v <- 2
  h_true <- matrix(rnorm(d * v), d, v)
  beta_true <- matrix(rnorm(k * v), k, v)
  Y <- matrix(0, nrow(sample_times), v)
  for (c in seq_along(X_list)) {
    Y <- Y + (X_list[[c]] %*% h_true) *
      matrix(rep(beta_true[c, ], each = nrow(Y)), nrow(Y), v)
  }
  Y <- Y + matrix(rnorm(length(Y), sd = noise_sd), nrow(Y), v)
  attr(Y, "sampling_frame") <- sf
  list(Y = Y, event_model = emod)
}


test_that("estimate_hrf_cfals integrates across HRF bases and terms", {
  bases <- list(HRF_SPMG3, hrfspline_generator(nbasis = 4))
  for (b in bases) {
    dat <- simulate_multiterm_data(b)
    for (term in c("hrf(term1)", "hrf(term2)")) {
      fit <- estimate_hrf_cfals(dat$Y, dat$event_model, term, b,
                                lambda_b = 0.1, lambda_h = 0.1)
      expect_s3_class(fit, "hrfals_fit")
      expect_equal(nrow(fit$h_coeffs), nbasis(b))
      expect_equal(fit$target_event_term_name, term)
    }
  }
})

test_that("penalty_R_mat_type options work", {
  dat <- simulate_cfals_wrapper_data(HRF_SPMG3)

  fit_basis <- estimate_hrf_cfals(dat$Y, dat$event_model, "hrf(condition)",
                                  HRF_SPMG3,
                                  lambda_b = 0.1, lambda_h = 0.1,
                                  penalty_R_mat_type = "basis_default")
  expect_s3_class(fit_basis, "hrfals_fit")

  Rm <- diag(nbasis(HRF_SPMG3))
  fit_custom <- estimate_hrf_cfals(dat$Y, dat$event_model, "hrf(condition)",
                                   HRF_SPMG3,
                                   lambda_b = 0.1, lambda_h = 0.1,
                                   penalty_R_mat_type = "custom",
                                   R_mat = Rm)
  expect_s3_class(fit_custom, "hrfals_fit")

  expect_error(
    estimate_hrf_cfals(dat$Y, dat$event_model, "hrf(condition)", HRF_SPMG3,
                       lambda_b = 0.1, lambda_h = 0.1,
                       penalty_R_mat_type = "custom"),
    "R_mat must be supplied"
  )
})
</file>

<file path="R/cf_als_engine.R">
#' Confound-Free ALS HRF Estimation Engine
#'
#' Internal helper implementing the CF-ALS algorithm described in
#' `data-raw/CFALS_proposal.md`. Inputs should already be projected
#' to the confound null space.
#'
#' @param X_list_proj list of k design matrices (n x d each)
#' @param Y_proj numeric matrix of projected BOLD data (n x v)
#' @param lambda_b ridge penalty for beta-update
#' @param lambda_h ridge penalty for h-update
#' @param R_mat_eff effective d x d penalty matrix for h-update. If NULL a
#'   diagonal matrix is used.
#' @param fullXtX_flag logical; if TRUE use cross-condition terms in h-update
#' @param precompute_xty_flag logical; if TRUE precompute `XtY_list` otherwise
#'   compute per voxel on-the-fly
#' @param Phi_recon_matrix p x d matrix for sign alignment
#' @param h_ref_shape_canonical Canonical reference HRF shape of length p for
#'   sign alignment
#' @param max_alt number of alternating updates after initialization
#' @param epsilon_svd tolerance for singular value screening
#' @param epsilon_scale tolerance for scale in identifiability step
#' @return list with matrices `h` (d x v) and `beta` (k x v). The
#'   matrix `h` has an attribute `"iterations"` recording the number
#'   of alternating updates performed.
#' @keywords internal
#' @importFrom Matrix forceSymmetric
#' @noRd
cf_als_engine <- function(X_list_proj, Y_proj,
                          lambda_b = 10,
                          lambda_h = 1,
                          R_mat_eff = NULL,
                          fullXtX_flag = FALSE,
                          precompute_xty_flag = TRUE,
                          Phi_recon_matrix,
                          h_ref_shape_canonical,
                          max_alt = 1,
                          epsilon_svd = 1e-8,
                          epsilon_scale = 1e-8) {

  stopifnot(is.list(X_list_proj), length(X_list_proj) >= 1)
  n <- nrow(Y_proj)
  v <- ncol(Y_proj)
  d <- ncol(X_list_proj[[1]])
  k <- length(X_list_proj)
  if (!is.matrix(Phi_recon_matrix) || ncol(Phi_recon_matrix) != d)
    stop("`Phi_recon_matrix` must be a p x d matrix")
  if (length(h_ref_shape_canonical) != nrow(Phi_recon_matrix))
    stop("`h_ref_shape_canonical` must have length nrow(Phi_recon_matrix)")
  for (X in X_list_proj) {
    if (nrow(X) != n) stop("Design matrices must have same rows as Y_proj")
    if (ncol(X) != d) stop("All design matrices must have the same column count")
  }
  if (lambda_b < 0 || lambda_h < 0) {
    stop("lambda_b and lambda_h must be non-negative")
  }

  if (!is.null(R_mat_eff)) {
    if (!is.matrix(R_mat_eff) || nrow(R_mat_eff) != d || ncol(R_mat_eff) != d) {
      stop(paste("R_mat_eff must be a d x d matrix, where d is", d))
    }
  }

  cholSolve <- function(M, b, eps = max(epsilon_svd, epsilon_scale)) {
    ok <- TRUE
    L  <- tryCatch(chol(M), error = function(e) { ok <<- FALSE ; NULL })
    if (!ok || (is.null(L) || min(diag(L)) < eps)) {
      L <- chol(M + eps * diag(nrow(M)))
    }
    backsolve(L, forwardsolve(t(L), b))
  }

  init <- ls_svd_engine(X_list_proj, Y_proj,
                        lambda_init = 0,
                        Phi_recon_matrix = Phi_recon_matrix,
                        h_ref_shape_canonical = h_ref_shape_canonical,
                        epsilon_svd = epsilon_svd,
                        epsilon_scale = epsilon_scale)
  h_current <- init$h
  b_current <- init$beta

  XtX_list <- lapply(X_list_proj, crossprod)


  size_est <- as.numeric(k) * d * v * 8
  if (precompute_xty_flag && size_est > 2e9) {
    message("Estimated size of XtY_list (", size_est,
            " bytes) is large; consider `precompute_xty_flag = FALSE`")
  }
  XtY_list <- if (precompute_xty_flag) {
    lapply(X_list_proj, function(X) crossprod(X, Y_proj))
  } else {
    NULL

  }

  if (fullXtX_flag) {
    XtX_full_list <- matrix(vector("list", k * k), k, k)
    for (l in seq_len(k)) {
      for (m in seq_len(k)) {
        XtX_full_list[[l, m]] <- crossprod(X_list_proj[[l]], X_list_proj[[m]])
      }
    }
  } else {
    XtX_full_list <- NULL
  }

  iter_final <- 0
  for (iter in seq_len(max_alt)) {
    b_prev <- b_current
    h_prev <- h_current
    for (vx in seq_len(v)) {
      h_vx <- h_current[, vx]

      if (!isTRUE(precompute_xty_flag)) {
        XtY_cache <- vector("list", k)
        for (l in seq_len(k)) {
          XtY_cache[[l]] <- crossprod(X_list_proj[[l]], Y_proj[, vx])
        }
      }

      DhTy_vx <- vapply(seq_len(k), function(c) {
        XtY_c_vx <- if (isTRUE(precompute_xty_flag)) {
          XtY_list[[c]][, vx]
        } else {
          XtY_cache[[c]]
        }
        crossprod(h_vx, XtY_c_vx)

      }, numeric(1))
      G_vx <- matrix(0.0, k, k)
      for (l in seq_len(k)) {
        if (fullXtX_flag) {
          for (m in seq_len(k)) {
            term <- XtX_full_list[[l, m]]
            G_vx[l, m] <- crossprod(h_vx, term %*% h_vx)
          }
        } else {
          G_vx[l, l] <- crossprod(h_vx, XtX_list[[l]] %*% h_vx)
        }
      }
      b_current[, vx] <- cholSolve(G_vx + lambda_b * diag(k), DhTy_vx)
    }

    h_penalty_matrix <- if (is.null(R_mat_eff)) {
      diag(d)
    } else {
      R_mat_eff
    }

    for (vx in seq_len(v)) {

      if (!isTRUE(precompute_xty_flag)) {
        XtY_cache <- vector("list", k)
        for (l in seq_len(k)) {
          XtY_cache[[l]] <- crossprod(X_list_proj[[l]], Y_proj[, vx])
        }
      }

      b_vx <- b_current[, vx]
      lhs <- lambda_h * h_penalty_matrix
      rhs <- numeric(d)

      if (!isTRUE(precompute_xty_flag)) {
        XtY_cache <- vector("list", k)
        for (l in seq_len(k)) {
          XtY_cache[[l]] <- crossprod(X_list_proj[[l]], Y_proj[, vx])
        }
      }
      for (l in seq_len(k)) {

        XtY_l_vx <- if (isTRUE(precompute_xty_flag)) {
          XtY_list[[l]][, vx]
        } else {
          XtY_cache[[l]]
        }
        rhs <- rhs + b_vx[l] * XtY_l_vx
        if (fullXtX_flag) {
          for (m in seq_len(k)) {
            lhs <- lhs + b_vx[l] * b_vx[m] * XtX_full_list[[l, m]]
          }
        } else {
          lhs <- lhs + b_vx[l]^2 * XtX_list[[l]]
        }
      }
    h_current[, vx] <- cholSolve(lhs, rhs)
    }

    iter_final <- iter
    if (max(abs(b_current - b_prev)) < 1e-6 &&
        max(abs(h_current - h_prev)) < 1e-6) {
      break
    }
  }

  H_shapes_iter <- Phi_recon_matrix %*% h_current
  scl <- apply(abs(H_shapes_iter), 2, max)
  flip <- rep(1.0, v)
  align_scores <- colSums(H_shapes_iter * h_ref_shape_canonical)
  flip[align_scores < 0 & scl > epsilon_scale] <- -1.0
  eff_scl <- pmax(scl, epsilon_scale)
  h_final <- sweep(h_current, 2, flip / eff_scl, "*")
  b_final <- sweep(b_current, 2, flip * eff_scl, "*")
  zero_idx <- scl <= epsilon_scale
  if (any(zero_idx)) {
    h_final[, zero_idx] <- 0
    b_final[, zero_idx] <- 0
  }

  attr(h_final, "iterations") <- iter_final
  list(h = h_final, beta = b_final)
}
</file>

</files>
