% Generated by roxygen2: do not edit by hand

% Please edit documentation in R/cfals_wrapper.R
\name{hrfals}
\alias{hrfals}
\title{Fit Rank-1 HRF Using CF-ALS}
\usage{
hrfals(
  fmri_data_obj,
  event_model,
  hrf_basis,
  confound_obj = NULL,
  lam_beta = 10,
  lam_h = 1,
  R_mat = NULL,
  fullXtX = FALSE,
  max_alt = 1,
  ...
)
}
\arguments{
\item{fmri_data_obj}{An `fmri_dataset` or numeric matrix of BOLD data
(time points x voxels). If a dataset, sampling information is
taken from the object.}

\item{event_model}{An `event_model` describing the stimuli to use
for HRF estimation.}

\item{hrf_basis}{An `HRF` basis object from the `fmrireg` package
(e.g., `HRF_BSPLINE`, `HRF_TENT`, `HRF_SPMG3`). This determines the
set of basis functions used to model the HRF. The CF-ALS method
can work with any basis where `nbasis > 1`.}

\item{confound_obj}{Optional numeric matrix of confound regressors (time
points x number of confounds). These nuisance variables are projected
out from the BOLD data and design matrices prior to CF-ALS estimation.
Defaults to `NULL` (no confounds).}

\item{lam_beta}{Numeric. The regularization parameter for the beta (amplitude)
update step. Controls the L2 penalty on the amplitude coefficients.
Defaults to 10.}

\item{lam_h}{Numeric. The regularization parameter for the h (HRF coefficient)
update step. Controls the L2 penalty on the HRF basis coefficients.
Defaults to 1.}

\item{R_mat}{Optional penalty matrix for the h (HRF coefficient) update.
If `NULL` (default), an identity matrix is used, corresponding to a simple
ridge penalty. If a basis-specific penalty (e.g., for smoothing) is
available from `hrf_basis`, it can be passed here.}

\item{fullXtX}{Logical. If `TRUE`, the h-update step uses the full
Gramian matrix \eqn{(\sum_l \beta_l X_l)^\top (\sum_m \beta_m X_m)},
including cross-condition terms \eqn{\beta_l \beta_m X_l^\top X_m}.
If `FALSE` (default), cross-condition terms are omitted and the
Gramian is approximated by \eqn{\sum_l \beta_l^2 X_l^\top X_l}. In
both cases a single shared HRF coefficient vector is estimated per
voxel.}

\item{max_alt}{Integer. The maximum number of alternations between the beta
and h updates. The proposal notes that empirically one alternation
(`max_alt = 1`) after SVD initialization is often sufficient.
Defaults to 1.}

\item{...}{Additional arguments passed to the underlying estimation engine.}
}
\value{
An object of class `fmrireg_cfals_fit`. This object contains:
  \itemize{
    \item `h`: A d x v matrix of HRF basis coefficients (d = number of basis functions, v = number of voxels).
    \item `beta`: A k x v matrix of condition amplitudes (k = number of conditions).
    \item `reconstructed_hrfs`: A p x v matrix of the actual HRF shapes (p = length of HRF, v = number of voxels), reconstructed using the `hrf_basis` and the estimated `h` coefficients.
    \item `residuals`: An n x v matrix of model residuals after fitting (n = number of timepoints).
    \item `hrf_basis_used`: The `hrf_basis` object that was supplied to the function.
    \item `lambdas_used`: A named list or vector containing the regularization parameters (`lam_beta`, `lam_h`) used in the estimation.
    \item `design_info`: A list containing dimensions and flags used during estimation (e.g., d, k, n, v, `fullXtX`).
    \item `gof_per_voxel`: Optional. Goodness-of-fit statistics per voxel, such as R-squared.
    \item (Other elements as defined by the `fmrireg_cfals_fit` class structure from the proposal, like `call`).
  }
}
\description{
Convenience wrapper for the original CF-ALS implementation.  This
function simply calls [fmrireg_cfals()] with `method = "cf_als"` and
retains the historical argument names.
}
\details{
This function implements the Confound-Free Alternating Least Squares (CF-ALS)
algorithm for data-driven estimation of Hemodynamic Response Functions (HRFs)
from fMRI data. It estimates HRF coefficients (`h`) and activation
amplitudes (`beta`) simultaneously using a rank-1 decomposition model:
Y ≈ D(h)β^T, where D(h) is the design matrix formed by convolving
stimulus onsets with the HRF (`h`).

Key steps of the algorithm include:
\enumerate{
  \item Confound Projection: Nuisance regressors (if provided via `confound_obj`) are removed from both the BOLD data (Y) and the HRF basis design matrices (X.list) using QR-based orthogonal projection.
  \item Precomputation: Quantities like X^T X and X^T Y are precomputed for efficiency.
  \item SVD Initialization: Robust starting values for `h` and `beta` are obtained using a regularized least squares solution followed by Singular Value Decomposition (SVD) of the initial coefficient estimates. (This is handled by the main `fmrireg_cfals` function when `method="cf_als"`).
  \item CF-ALS Alternation: The algorithm alternates between updating `beta` (amplitudes) holding `h` (HRF coefficients) fixed, and updating `h` holding `beta` fixed. This process is repeated for `max_alt` iterations.
    \itemize{
      \item β-update: Solves (G_mat + λ_β I)β_v = D(h)^T y_v for each voxel v, where G_mat = D(h)^T D(h).
      \item h-update: Solves (LHS + λ_h I)h = RHS, where LHS and RHS depend on the data and current beta estimates. The `fullXtX` parameter influences the construction of LHS.
    }
  \item Identifiability: The estimated HRF coefficients `h` are typically normalized (e.g., ||Φh||_∞ = 1, where Φ is the basis reconstruction matrix) and their sign aligned with a canonical HRF shape to ensure consistent scaling and polarity across voxels/conditions.
}

The function is designed to be compatible with any HRF basis defined in the
`fmrireg` package (provided `nbasis(hrf_basis) > 1`). The `R_mat`
parameter allows for basis-specific penalty matrices for HRF coefficient
regularization, although the default is an identity matrix (standard ridge penalty).

R\eqn{^2} (coefficient of determination) is computed on the data *after*
any confound projection has been applied.
}
\examples{
# Simulate data
sframe <- fmrireg::sampling_frame(blocklens = 40, TR = 1)
ev_df <- data.frame(onset = c(5, 15, 25), block = 1, cond = "A")
emod <- fmrireg::event_model(onset ~ hrf(cond, basis = fmrireg::HRF_SPMG3),
                             data = ev_df, block = ~ block,
                             sampling_frame = sframe)
Y_matrix <- matrix(rnorm(40 * 5), 40, 5) # 40 timepoints, 5 voxels

# Fit using hrfals
cfals_fit <- hrfals(
  fmri_data_obj = Y_matrix,
  event_model = emod,
  hrf_basis = fmrireg::HRF_SPMG3, # Using SPMG3 basis (3 basis functions)
  lam_beta = 5,
  lam_h = 0.5,
  max_alt = 1
)

print(cfals_fit)
summary(cfals_fit) # If a summary method is defined
# plot(cfals_fit)    # If a plot method is defined

# Example with B-spline basis
bspline_basis <- fmrireg::HRF_BSPLINE(knots = c(0, 4, 8, 12, 20))
emod_bspline <- fmrireg::event_model(onset ~ hrf(cond, basis = bspline_basis),
                                     data = ev_df, block = ~ block,
                                     sampling_frame = sframe)
cfals_fit_bspline <- hrfals(
  fmri_data_obj = Y_matrix,
  event_model = emod_bspline,
  hrf_basis = bspline_basis,
  max_alt = 2
)
print(cfals_fit_bspline)

}
\references{
(If applicable, add references to papers describing the CF-ALS method or its implementation).
}
\seealso{
[fmrireg_cfals()] for the more general wrapper allowing different estimation methods.

% Please edit documentation in R/hrfals_interface.R
\name{hrfals}
\alias{hrfals}
\title{Fit HRFs using CF-ALS}
\usage{
hrfals(y, design, method = "cf_als", control = list(), ...)
}
\arguments{
  \item{y}{Numeric matrix of BOLD data (time points x voxels).}
  \item{design}{List produced by \code{create_cfals_design()} containing at least
    \code{event_model} and \code{hrf_basis}.}
  \item{method}{Estimation engine to use. Passed to \code{fmrireg_cfals}.}
  \item{control}{List of algorithm parameters overriding
    \code{hrfals_control_defaults()}.}
  \item{...}{Additional arguments forwarded to \code{fmrireg_cfals}.}
}
\value{
An object of class \code{fmrireg_cfals_fit}.
}
\description{
High level interface that merges user options with
\code{hrfals_control_defaults()} and dispatches to \code{fmrireg_cfals}.

}
