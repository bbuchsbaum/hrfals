% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fastlss_voxel.R
\name{lss_mode_b}
\alias{lss_mode_b}
\alias{fastlss_voxel}
\title{Fast LSS Mode B (voxel-specific trial regressors)}
\usage{
lss_mode_b(
  Y,
  A,
  X_onset_list,
  H_allvoxels,
  p_vec,
  lambda_ridge = 0,
  woodbury_thresh = 50,
  chunk_size = NULL,
  progress = FALSE,
  mem_limit = NULL,
  W = NULL
)

fastlss_voxel(
  Y,
  A,
  X_onset_list,
  H_allvoxels,
  p_vec,
  lambda_ridge = 0,
  woodbury_thresh = 50,
  chunk_size = NULL,
  progress = FALSE,
  mem_limit = NULL,
  W = NULL
)
}
\arguments{
\item{Y}{Numeric matrix of BOLD data (n x v).}

\item{A}{Numeric matrix of nuisance regressors (n x m).}

\item{X_onset_list}{List of length T containing onset design matrices
(n x d each).}

\item{H_allvoxels}{Numeric matrix of HRF coefficients (d x v).}

\item{p_vec}{Numeric vector of length n as described in the proposal.}

\item{lambda_ridge}{Optional ridge penalty when computing the
pseudoinverse of \code{A}.}

\item{woodbury_thresh}{Threshold for switching from Woodbury to
QR-based residualisation. See \code{auto_residualize}.}

\item{chunk_size}{Optional chunk size (number of trials) used to
process per voxel when memory limits are a concern. Set
automatically when \code{mem_limit} is supplied.}

\item{progress}{Logical; display a progress bar over voxels when
\code{TRUE}.}

\item{mem_limit}{Optional memory limit in megabytes for automatic
chunking.}

\item{W}{Optional whitening matrix applied to `Y`, `A` and each
onset matrix before running the kernel.}
}
\value{
Numeric matrix of trial coefficients (T x v).
}
\description{
Implements the voxel-specific HRF variant of the fast least-squares
separate (LSS) algorithm described in `raw-data/FastLSS_proposal.md`.
Trial regressors for each voxel are constructed from a list of onset
matrices and a matrix of HRF basis coefficients. Computation is
performed voxel by voxel using BLAS-optimised operations.
}
