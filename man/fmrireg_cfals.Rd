% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cfals_wrapper.R
\name{fmrireg_cfals}
\alias{fmrireg_cfals}
\title{Estimate Rank-1 HRF Using LS+SVD/CF-ALS Methods}
\usage{
fmrireg_cfals(...)
}
\arguments{
\item{...}{Additional arguments passed to the underlying estimation engine.}

\item{fmri_data_obj}{An `fmri_dataset` or numeric matrix of BOLD data
(time points x voxels). If a dataset, sampling information is
taken from the object.}

\item{event_model}{An `event_model` describing the stimuli to use
for HRF estimation.}

\item{hrf_basis}{An `HRF` basis object used for the convolution
design matrices.}

\item{confound_obj}{Optional matrix of confound regressors with the
same number of rows as the data matrix.}

\item{method}{Estimation method. One of "ls_svd_only",
"ls_svd_1als" (default) or "cf_als".}

\item{lambda_init}{Ridge penalty for the initial GLM solve used by
`ls_svd` based methods.}

\item{lambda_b}{Ridge penalty for the beta update step. When
`beta_penalty$l1 > 0` this value is added to the Elastic Net L2
penalty; otherwise it is the sole L2 regularisation on the beta
coefficients.}

\item{lambda_h}{Ridge penalty for the h update step.}

\item{lambda_joint}{Joint ridge penalty applied to both beta and h updates.
This helps prevent see-saw effects between the two parameter blocks.
Recommended range: 0.2-2. Default is 0 (disabled).}

\item{R_mat}{Optional penalty matrix for the h (HRF coefficient) update.
If `NULL` (default), an identity matrix is used, corresponding to a simple
ridge penalty. If a basis-specific penalty (e.g., for smoothing) is
available from `hrf_basis`, it can be passed here.}

\item{fullXtX}{Logical. If `TRUE`, the h-update step uses the full
Gramian matrix \eqn{(\sum_l \beta_l X_l)^\top (\sum_m \beta_m X_m)},
including cross-condition terms \eqn{\beta_l \beta_m X_l^\top X_m}.
If `FALSE` (default), cross-condition terms are omitted and the
Gramian is approximated by \eqn{\sum_l \beta_l^2 X_l^\top X_l}.
In both cases a single shared HRF coefficient vector is estimated
per voxel.}

\item{precompute_xty_flag}{Logical; passed to `cf_als_engine` to control
precomputation of `XtY` matrices.}

\item{max_alt}{Number of alternating updates after initialisation
when `method = "cf_als"`.}
}
\value{
An object of class `hrfals_fit` containing the
  estimated HRF coefficients and amplitudes.
}
\description{
High level wrapper that prepares design matrices and dispatches to
the desired estimation engine.  This function supports the fast
\emph{LS+SVD} initialisation, the one-step refinement
\emph{LS+SVD+1ALS}, or the full alternating scheme implemented in
`cf_als_engine`.
}
\details{
The `method` argument selects between the closed-form
\code{"ls_svd_only"}, the default \code{"ls_svd_1als"} which adds one
ALS refinement step, or the iterative \code{"cf_als"} engine.  The
ridge penalties \code{lambda_init}, \code{lambda_b} and
\code{lambda_h} control regularisation of the initial solve, the
beta-update and the h-update respectively.  When
\code{fullXtX = TRUE} the h-update uses the full cross-condition
Gramian; otherwise an approximation ignoring off-diagonal terms is
used. R\eqn{^2} is computed on the
data after confound projection.
}
\examples{
\dontrun{
library(fmrireg)

# Create sampling frame and event model
sframe <- fmrireg::sampling_frame(blocklens = 40, TR = 1)
ev_df <- data.frame(onset = c(5, 15, 25), block = 1, cond = "A")
emod <- fmrireg::event_model(onset ~ hrf(cond), data = ev_df, 
                             block = ~ block, sampling_frame = sframe)

# Simulate some BOLD data
Y_matrix <- matrix(rnorm(40 * 5), 40, 5) # 40 timepoints, 5 voxels

# Fit using CF-ALS with SPMG3 basis (3 basis functions)
fit <- fmrireg_cfals(Y, emod, HRF_SPMG3)
print(fit)
}
}
\keyword{internal}
