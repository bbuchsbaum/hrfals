% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/estimate_hrf_cfals.R
\name{estimate_hrf_cfals}
\alias{estimate_hrf_cfals}
\title{Estimate HRF for a target event term using CF-ALS}
\usage{
estimate_hrf_cfals(
  fmri_data_obj,
  fmrireg_event_model,
  target_event_term_name,
  hrf_basis_for_cfals,
  confound_obj = NULL,
  baseline_model = NULL,
  method = c("ls_svd_1als", "ls_svd_only", "cf_als"),
  lambda_init = 1,
  lambda_b = 10,
  lambda_h = 1,
  lambda_joint = 0,
  lambda_s = 0,
  laplacian_obj = NULL,
  h_solver = c("direct", "cg", "auto"),
  cg_max_iter = 100,
  cg_tol = 1e-4,
  R_mat = c("identity", "basis_default"),
  fullXtX = FALSE,
  precompute_xty_flag = TRUE,
  max_alt = 1,
  beta_penalty = list(l1 = 0, alpha = 1, warm_start = TRUE),
  design_control = list(standardize_predictors = TRUE,
    cache_design_blocks = TRUE),
  hrf_shape_duration = attr(hrf_basis_for_cfals, "span"),
  hrf_shape_resolution = fmrireg_event_model$sampling_frame$TR[1],
  ...
)
}
\arguments{
\item{fmri_data_obj}{`fmrireg::fmri_dataset` or numeric BOLD matrix.}

\item{fmrireg_event_model}{An `event_model` describing the full design.}

\item{target_event_term_name}{Name of the event_term to estimate.}

\item{hrf_basis_for_cfals}{An `HRF` object with `nbasis > 1`.}

\item{confound_obj}{Optional confound matrix.}

\item{baseline_model}{Optional baseline model whose design matrix is
projected alongside \code{confound_obj}.}

\item{method}{Estimation engine to use ("ls_svd_only", "ls_svd_1als", "cf_als").}

\item{lambda_init}{Ridge penalty for initial LS solve.}

\item{lambda_b}{Ridge penalty for the beta update. When
\code{beta_penalty$l1 > 0} this value adds to the Elastic Net L2
component, otherwise it is the sole L2 penalty.}

\item{lambda_h}{Ridge penalty for the h update.}
\item{lambda_joint}{Joint penalty for the h update.}
\item{lambda_s}{Spatial regularization strength controlling the amount of
voxel-wise smoothing.  For comparable smoothing across different voxel
sizes consider scaling \code{lambda_s} by \code{1 / mean(voxel\_size)^2}.}
\item{laplacian_obj}{List containing the sparse Laplacian matrix \code{L} and
degree vector as returned by \code{build_voxel_laplacian}. Required when
\code{lambda_s > 0}.}
\item{h_solver}{Solver for the spatial h-update.}
\item{cg_max_iter}{Maximum iterations for CG solver.}
\item{cg_tol}{Tolerance for CG solver convergence.}

\item{R_mat}{Either the string \code{"identity"} (default) or
\code{"basis_default"} to request an automatically generated penalty
matrix, or a numeric matrix specifying a custom penalty for the h
update.}

\item{fullXtX}{Logical. If `TRUE`, the h-update step uses the full
Gramian matrix \eqn{(\sum_l \beta_l X_l)^\top (\sum_m \beta_m X_m)}
with cross-condition terms. If `FALSE` (default), the Gramian is
approximated by omitting cross-condition terms,
\eqn{\sum_l \beta_l^2 X_l^\top X_l}. A single shared HRF
coefficient vector is still estimated per voxel.}

\item{precompute_xty_flag}{Logical; passed to `cf_als_engine`.}

\item{max_alt}{Number of alternating updates for `cf_als`.}

\item{beta_penalty}{List with elements \code{l1}, \code{alpha}, and
\code{warm_start} controlling sparse beta estimation. Typical \code{l1}
values of 0.01--0.1 are useful for standardised predictors. Setting
\code{warm_start = TRUE} reuses betas from the previous iteration.}

\item{design_control}{List of design preprocessing options. When
\code{standardize_predictors = TRUE} predictors are z-scored and the
returned betas are rescaled. If \code{cache_design_blocks = TRUE} the
lagged design matrices are cached in memory when possible.}

\item{hrf_shape_duration}{Duration in seconds for reconstructed HRF grid.}

\item{hrf_shape_resolution}{Sampling resolution of the HRF grid.}
}
\value{
An `hrfals_fit` object.
}
\description{
High level wrapper around the CFALS engines operating on a single
`event_term` within an `fmrireg::event_model`. Design matrices and
projection are handled by `create_cfals_design`.
}
