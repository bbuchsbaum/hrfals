% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/estimate_hrf_cfals.R
\name{estimate_hrf_cfals}
\alias{estimate_hrf_cfals}
\title{Estimate HRF for a target event term using CF-ALS}
\usage{
estimate_hrf_cfals(
  fmri_data_obj,
  fmrireg_event_model,
  target_event_term_name,
  hrf_basis_for_cfals,
  confound_obj = NULL,
  baseline_model = NULL,
  method = c("ls_svd_1als", "ls_svd_only", "cf_als"),
  lambda_init = 1,
  lambda_b = 10,
  lambda_h = 1,
  lambda_joint = 0,
  lambda_s = 0,
  laplacian_obj = NULL,
  h_solver = c("direct", "cg", "auto"),
  cg_max_iter = 100,
  cg_tol = 1e-04,
  R_mat = c("identity", "basis_default"),
  fullXtX = FALSE,
  precompute_xty_flag = TRUE,
  max_alt = 10,
  beta_penalty = list(l1 = 0, alpha = 1, warm_start = TRUE),
  design_control = list(standardize_predictors = TRUE, cache_design_blocks = TRUE),
  hrf_shape_duration = attr(hrf_basis_for_cfals, "span"),
  hrf_shape_resolution = fmrireg_event_model$sampling_frame$TR[1],
  ...
)
}
\arguments{
\item{fmri_data_obj}{`fmrireg::fmri_dataset` or numeric BOLD matrix.}

\item{fmrireg_event_model}{An `event_model` describing the full design.}

\item{target_event_term_name}{Name of the event_term to estimate.}

\item{hrf_basis_for_cfals}{An `HRF` object with `nbasis > 1`.}

\item{confound_obj}{Optional confound matrix.}

\item{baseline_model}{Optional baseline model whose design matrix is
projected along with `confound_obj`.}

\item{method}{Estimation engine to use ("ls_svd_only", "ls_svd_1als", "cf_als").}

\item{lambda_init}{Ridge penalty for initial LS solve.}

\item{lambda_b}{Ridge penalty for the beta update. When
`beta_penalty$l1 > 0` this value adds to the Elastic Net L2
component, otherwise it is the sole L2 penalty as in classic CF-ALS.}

\item{lambda_h}{Ridge penalty for the h update.}

\item{lambda_joint}{Joint penalty for the h update.}

\item{lambda_s}{Spatial regularization strength controlling the amount of
voxel-wise smoothing.  The effective physical smoothness depends on the
value of `lambda_s` relative to the voxel size.  For similar behaviour
across datasets with different resolutions consider scaling
`lambda_s` by `1 / mean(voxel_size)^2`.  Set to zero to disable spatial
smoothing.}

\item{laplacian_obj}{Optional list containing the Laplacian matrix `L` and
degree vector `degree` as returned by [build_voxel_laplacian()].
Required when `lambda_s > 0`.}

\item{h_solver}{Solver to use for the spatial h-update. One of
"direct", "cg" or "auto".}

\item{cg_max_iter}{Maximum iterations for the conjugate gradient solver when
`h_solver = "cg"`.}

\item{cg_tol}{Convergence tolerance for the conjugate gradient solver.}

\item{R_mat}{Either the character string "identity" (default) or
"basis_default" to indicate how the penalty matrix should be
constructed, or a numeric matrix providing a custom penalty for the
h update.}

\item{fullXtX}{Logical. If `TRUE`, the h-update step uses the full
Gramian matrix \eqn{(\sum_l \beta_l X_l)^\top (\sum_m \beta_m X_m)}
with cross-condition terms. If `FALSE` (default), the Gramian is
approximated by omitting cross-condition terms,
\eqn{\sum_l \beta_l^2 X_l^\top X_l}. A single shared HRF
coefficient vector is still estimated per voxel.}

\item{precompute_xty_flag}{Logical; passed to `cf_als_engine`.}

\item{max_alt}{Number of alternating updates for `cf_als`.}

\item{beta_penalty}{List with elements `l1`, `alpha`, and `warm_start`
controlling sparse beta estimation. Set `l1 > 0` to engage the
Elastic Net solver with mixing parameter `alpha` in \[0,1\]. Typical
`l1` values between 0.01 and 0.1 work well for standardised inputs.
When `warm_start = TRUE` the previous iteration's betas are used as the
starting point which improves convergence.}

\item{design_control}{List of design matrix processing options. Set
`standardize_predictors = TRUE` to z-score continuous predictors
before estimation. Resulting betas are rescaled back to the original
predictor units. If `cache_design_blocks = TRUE` the time-lagged
predictor matrices are stored in memory when feasible to accelerate
repeated HRF updates.}

\item{hrf_shape_duration}{Duration in seconds for reconstructed HRF grid.}

\item{hrf_shape_resolution}{Sampling resolution of the HRF grid.}
}
\value{
An `hrfals_fit` object.
}
\description{
High level wrapper around the CFALS engines operating on a single
`event_term` within an `fmrireg::event_model`. Design matrices and
projection are handled by `create_cfals_design`.
}
