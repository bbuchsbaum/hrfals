---
title: "Preparing CF-ALS designs with confounds"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Preparing CF-ALS designs with confounds}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
params:
  family: red
css: albers.css
resource_files:
- albers.css
- albers.js
includes:
  in_header: |-
    <script src="albers.js"></script>
    <script>document.addEventListener('DOMContentLoaded',function(){document.body.classList.add('palette-red');});</script>

---

```{r setup, include=FALSE}
if (requireNamespace("ggplot2", quietly = TRUE) && requireNamespace("albersdown", quietly = TRUE)) ggplot2::theme_set(albersdown::theme_albers(params$family))
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
set.seed(123)
```

## Why confound projection matters

Scanner drift, head motion, and physiological noise share variance with
task-related signals.
If you estimate an HRF without removing these nuisance components first,
the recovered shape will be distorted and condition amplitudes biased.

`create_cfals_design()` handles this by projecting confounds out of both
the BOLD data and the design matrices **before** they reach the CF-ALS
solver.
This vignette shows how to build a confound-projected design, inspect its
components, and feed it to the estimation engine.

## Simulated experiment

We start with a two-condition event model sampled every second for a short
run. We also create a small confound matrix representing motion parameters
or nuisance signals.

```{r}
library(hrfals)
library(fmridesign)

TR <- 1
n_time <- 120
sf <- sampling_frame(blocklens = n_time, TR = TR)

events <- data.frame(
  onset = c(10, 26, 48, 72, 90),
  condition = factor(c("A", "B", "A", "B", "A")),
  block = 1
)

emod <- event_model(
  onset ~ hrf(condition),
  data = events,
  block = ~ block,
  sampling_frame = sf
)

hrf_basis <- fmrihrf::HRF_FIR

# Simple confound matrix: drift + random nuisance
confound_obj <- cbind(
  drift    = scale(seq_len(n_time)),
  nuisance = rnorm(n_time)
)
```

Next we simulate a small BOLD matrix with three voxels using a fixed HRF
and the design blocks produced by `create_fmri_design()`.

```{r}
design <- create_fmri_design(emod, hrf_basis)

h_coeffs_true <- c(0, 1.5, 2.5, 1.5, 0.5, rep(0, design$d - 5))

signal <- vapply(design$X_list,
                 function(X) drop(X %*% h_coeffs_true),
                 numeric(n_time))

beta_true <- setNames(c(1.2, -0.8), colnames(signal))
Y_clean   <- as.numeric(signal %*% beta_true)
Y <- matrix(Y_clean, n_time, 3) +
     matrix(rnorm(n_time * 3, sd = 0.15), n_time)
```

## Building the CF-ALS design

With the simulated BOLD data, event model, HRF basis, and confounds in
hand, call `create_cfals_design()`.
The helper returns the projected BOLD matrix, projected design blocks, and
bookkeeping values that downstream solvers reuse.

```{r}
cfals_inputs <- create_cfals_design(
  fmri_data_obj  = Y,
  event_model    = emod,
  hrf_basis      = hrf_basis,
  confound_obj   = confound_obj,
  design_control = list(standardize_predictors = TRUE,
                        cache_design_blocks = FALSE)
)

names(cfals_inputs)
```

## Inspecting the projected components

The projected data and design blocks have the same number of rows as the
original run, but confounds have already been removed.

```{r}
str(list(
  Y_proj       = dim(cfals_inputs$Y_proj),
  first_block  = dim(cfals_inputs$X_list_proj[[1]]),
  n_conditions = cfals_inputs$k_conditions,
  basis_dim    = cfals_inputs$d_basis_dim
))
```

The object also exposes the reconstruction matrix (`Phi_recon_matrix`) and
canonical reference shape used to orient estimated HRFs. These are useful
when visualising results or when passing outputs to lower-level engines
such as `cf_als_engine()`.

## Running CF-ALS on the prepared design

The simplest path is to pass everything through `hrfals()`, which calls
`create_cfals_design()` internally. But when you need fine-grained control
--- for instance to swap confound sets without rebuilding the full design
--- you can drive the engine directly:

```{r fig.width=6, fig.height=3, fig.alt="Estimated HRF from the CF-ALS engine"}
fit <- hrfals:::cf_als_engine(
  X_list_proj            = cfals_inputs$X_list_proj,
  Y_proj                 = cfals_inputs$Y_proj,
  lambda_b               = 0.1,
  lambda_h               = 0.1,
  Phi_recon_matrix       = cfals_inputs$Phi_recon_matrix,
  h_ref_shape_canonical  = cfals_inputs$h_ref_shape_canonical,
  max_alt                = 1,
  precompute_xty_flag    = TRUE,
  fullXtX_flag           = TRUE
)

time_points <- seq(0, by = cfals_inputs$sampling_frame$TR[1],
                   length.out = nrow(cfals_inputs$Phi_recon_matrix))
hrf_est <- drop(cfals_inputs$Phi_recon_matrix %*% fit$h[, 1])

plot(time_points, hrf_est, type = "l",
     xlab = "Time (s)", ylab = "HRF (a.u.)",
     main = "Estimated HRF (voxel 1)")
```

For most workflows you should use `hrfals()` rather than the internal
engine. Understanding what `create_cfals_design()` returns is still
valuable when you need to customise confound handling or integrate with
bespoke pipelines.

## Next steps

- `vignette("hrfals")` --- end-to-end getting started guide.
- `vignette("trialwise_beta_series")` --- derive trial-wise betas from a
  CF-ALS fit.
- `?create_cfals_design`, `?project_confounds` --- function reference for
  design and confound utilities.
