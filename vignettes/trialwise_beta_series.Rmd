---
title: "Trial-wise beta series with hrfals"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Trial-wise beta series with hrfals}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
params:
  family: red
css: albers.css
resource_files:
- albers.css
- albers.js
includes:
  in_header: |-
    <script src="albers.js"></script>
    <script>document.addEventListener('DOMContentLoaded',function(){document.body.classList.add('palette-red');});</script>

---

```{r setup, include=FALSE}
if (requireNamespace("ggplot2", quietly = TRUE) && requireNamespace("albersdown", quietly = TRUE)) ggplot2::theme_set(albersdown::theme_albers(params$family))
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
set.seed(123)
```

## Why trial-wise betas?

Many downstream analyses --- functional connectivity, representational
similarity analysis (RSA), and multivariate pattern analysis (MVPA) ---
need one activation estimate per trial, not one per condition.
Least-Squares Separate (LSS) is the standard approach: fit a separate
regression for each trial where that trial's regressor is isolated from all
others.

`hrfals_lss()` builds on this idea but with a key advantage: it uses the
data-driven HRF recovered by `hrfals()` rather than an assumed canonical
shape.
Better HRFs yield cleaner trial-wise betas.

## Simulated data

We set up a short run with five events (two conditions) and two voxels.

```{r}
library(hrfals)
library(fmridesign)

TR <- 1
n_time <- 80
sf <- sampling_frame(blocklens = n_time, TR = TR)

events <- data.frame(
  onset    = c(4, 16, 30, 45, 58),
  label    = factor(c("cue", "stim", "cue", "stim", "cue")),
  trial_id = factor(paste0("trial", seq_len(5))),
  stim     = factor("stim"),
  block    = 1
)
```

We create two event models: one with condition labels (for interpretable
HRF estimation) and one that pools all events into a single regressor
(useful when you want a label-free pipeline for MVPA).

```{r}
emod <- event_model(
  onset ~ hrf(label),
  data = events,
  block = ~ block,
  sampling_frame = sf
)

emod_pooled <- event_model(
  onset ~ hrf(stim),
  data = events,
  block = ~ block,
  sampling_frame = sf
)

hrf_basis <- fmrihrf::HRF_SPMG3
```

Now simulate BOLD data with a known HRF shape and condition amplitudes.

```{r}
h_coeffs <- c(1.3, 0.5, -0.2)
design   <- create_fmri_design(emod, hrf_basis)

cond_signal <- vapply(design$X_list,
                      function(X) drop(X %*% h_coeffs),
                      numeric(n_time))
dimnames(cond_signal) <- list(NULL, names(design$X_list))

beta_true <- matrix(c(1.0, -0.5,
                       0.7, -0.3),
                    nrow = 2,
                    dimnames = list(names(design$X_list), c("vox1", "vox2")))

Y <- cond_signal %*% beta_true +
     matrix(rnorm(n_time * 2, sd = 0.2), n_time, 2)
colnames(Y) <- c("vox1", "vox2")
```

## Step 1: Estimate the shared HRF

```{r}
cf_fit <- hrfals(
  fmri_data_obj = Y,
  event_model   = emod,
  hrf_basis     = hrf_basis,
  lam_beta      = 5,
  lam_h         = 1,
  max_alt       = 1
)

cf_fit
```

You can swap in a faster engine with `method = "ls_svd_only"` or
`method = "ls_svd_1als"` if you need a quick baseline.

## Step 2: Compute trial-wise betas

Pass the fitted HRF and the events to `hrfals_lss()`. The `formula`
argument tells it which column identifies individual trials.

```{r}
beta_series <- hrfals_lss(
  cf_fit        = cf_fit,
  events        = events,
  fmri_data_obj = Y,
  formula       = onset ~ hrf(trial_id),
  TR            = TR
)

dim(beta_series$betas)
```

The result is a `fastlss_fit` object with a trial-by-voxel coefficient
matrix --- one row per event.

```{r}
head(beta_series$betas)
```

## MVPA-friendly variant: pooled HRF

If you want to keep condition labels out of the regression model entirely,
estimate a single pooled HRF first:

```{r}
cf_fit_pooled <- hrfals(
  fmri_data_obj = Y,
  event_model   = emod_pooled,
  hrf_basis     = hrf_basis,
  lam_beta      = 5,
  lam_h         = 1,
  max_alt       = 1
)

beta_series_pooled <- hrfals_lss(
  cf_fit        = cf_fit_pooled,
  events        = events,
  fmri_data_obj = Y,
  formula       = onset ~ hrf(trial_id),
  TR            = TR
)

dim(beta_series_pooled$betas)
```

The `events$label` column remains available for downstream classification
but never enters the regression model.

```{r eval=FALSE}
# Join betas back to condition labels
trial_labels <- setNames(events$label, events$trial_id)

X_feat <- beta_series_pooled$betas[, "vox1", drop = FALSE]
y_lab  <- trial_labels[rownames(beta_series_pooled$betas)]
```

## Shared vs. voxel-specific HRFs

`hrfals_lss()` automatically selects the LSS kernel based on the fitted HRF:

- **Shared mode** (default when `cf_fit` has a single HRF column): one HRF
  applied to all voxels. Uses `fastlss_shared()`.
- **Voxel mode** (when `cf_fit$h_coeffs` has multiple columns): each voxel
  gets its own HRF-shaped regressors. Uses `fastlss_voxel()`.

You can force a mode with `mode = "shared"` or `mode = "voxel"`.

## Next steps

- `vignette("hrfals")` --- getting started with CF-ALS.
- `vignette("many_continuous_predictors")` --- sparse CF-ALS when the
  number of predictors is large.
- `?hrfals_lss`, `?fastlss_shared`, `?fastlss_voxel` --- function
  reference.
